"use strict";(self.webpackChunkdoc_website=self.webpackChunkdoc_website||[]).push([[3544],{7228:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>u,contentTitle:()=>d,default:()=>x,frontMatter:()=>a,metadata:()=>n,toc:()=>o});const n=JSON.parse('{"id":"core-components/shader-system/texture-inputs","title":"Texture Inputs","description":"Texture inputs are a fundamental part of KraftShade\'s shader system, allowing shaders to process image data. This document explains how texture inputs are managed and used within the KraftShade framework.","source":"@site/docs/core-components/shader-system/texture-inputs.md","sourceDirName":"core-components/shader-system","slug":"/core-components/shader-system/texture-inputs","permalink":"/android-kraft-shade/docs/core-components/shader-system/texture-inputs","draft":false,"unlisted":false,"editUrl":"https://github.com/cardinalblue/android-kraft-shade/tree/main/doc_website/docs/core-components/shader-system/texture-inputs.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"GlUniformDelegate","permalink":"/android-kraft-shade/docs/core-components/shader-system/gl-uniform-delegate"},"next":{"title":"Pipeline Running Flow","permalink":"/android-kraft-shade/docs/core-components/pipeline-system/pipeline-running-flow"}}');var i=r(4848),s=r(8453);const a={sidebar_position:3},d="Texture Inputs",u={},o=[{value:"Overview",id:"overview",level:2},{value:"Texture Input Classes Hierarchy",id:"texture-input-classes-hierarchy",level:2},{value:"TextureInputKraftShader",id:"textureinputkraftshader",level:3},{value:"TwoTextureInputKraftShader",id:"twotextureinputkraftshader",level:3},{value:"ThreeTextureInputKraftShader",id:"threetextureinputkraftshader",level:3},{value:"KraftShaderTextureInput",id:"kraftshadertextureinput",level:2},{value:"Texture and TextureProvider",id:"texture-and-textureprovider",level:2},{value:"Texture",id:"texture",level:3},{value:"TextureProvider",id:"textureprovider",level:3},{value:"Texture Implementations",id:"texture-implementations",level:2},{value:"LoadedTexture",id:"loadedtexture",level:3},{value:"TextureBuffer",id:"texturebuffer",level:3},{value:"Using Texture Inputs in Shaders",id:"using-texture-inputs-in-shaders",level:2},{value:"Basic Usage with TextureInputKraftShader",id:"basic-usage-with-textureinputkraftshader",level:3},{value:"Using TwoTextureInputKraftShader",id:"using-twotextureinputkraftshader",level:3},{value:"Setting Textures in Shaders",id:"setting-textures-in-shaders",level:2},{value:"Direct Texture Setting",id:"direct-texture-setting",level:3},{value:"Using TextureProvider",id:"using-textureprovider",level:3},{value:"In Pipeline DSL",id:"in-pipeline-dsl",level:3},{value:"Texture Coordinate Transformation",id:"texture-coordinate-transformation",level:2},{value:"Custom Texture Inputs",id:"custom-texture-inputs",level:2},{value:"Creating Custom Texture Inputs",id:"creating-custom-texture-inputs",level:3},{value:"Understanding KraftShaderTextureInput",id:"understanding-kraftshadertextureinput",level:3},{value:"Using Custom Texture Inputs in GLSL",id:"using-custom-texture-inputs-in-glsl",level:3},{value:"Important Considerations",id:"important-considerations",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Texture Management",id:"texture-management",level:3},{value:"Performance Considerations",id:"performance-considerations",level:3},{value:"Shader Development",id:"shader-development",level:3},{value:"Common Pitfalls",id:"common-pitfalls",level:2},{value:"Related Components",id:"related-components",level:2}];function l(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"texture-inputs",children:"Texture Inputs"})}),"\n",(0,i.jsx)(t.p,{children:"Texture inputs are a fundamental part of KraftShade's shader system, allowing shaders to process image data. This document explains how texture inputs are managed and used within the KraftShade framework."}),"\n",(0,i.jsx)(t.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(t.p,{children:"In OpenGL ES, textures are used to provide image data to shaders. KraftShade provides a structured way to manage these textures through its texture input system. This system handles:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Binding textures to shader programs"}),"\n",(0,i.jsx)(t.li,{children:"Managing texture coordinates"}),"\n",(0,i.jsx)(t.li,{children:"Providing texture size information to shaders"}),"\n",(0,i.jsx)(t.li,{children:"Supporting multiple texture inputs for complex effects"}),"\n"]}),"\n",(0,i.jsx)(t.mermaid,{value:"flowchart TD\n    A[TextureInputKraftShader] --\x3e|Base class for| B[Single Texture Shaders]\n    A --\x3e|Extended by| C[TwoTextureInputKraftShader]\n    C --\x3e|Base class for| D[Blend Shaders]\n    C --\x3e|Extended by| E[ThreeTextureInputKraftShader]\n    E --\x3e|Base class for| F[Complex Effect Shaders]\n    \n    style A fill:#c73,stroke:#333,stroke-width:2px,font-size:24px,font-weight:bold,white-space: nowrap"}),"\n",(0,i.jsx)(t.h2,{id:"texture-input-classes-hierarchy",children:"Texture Input Classes Hierarchy"}),"\n",(0,i.jsx)(t.p,{children:"KraftShade provides a hierarchy of classes for handling different numbers of texture inputs:"}),"\n",(0,i.jsx)(t.h3,{id:"textureinputkraftshader",children:"TextureInputKraftShader"}),"\n",(0,i.jsx)(t.p,{children:"The base class for shaders that require a single texture input. It provides:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Methods to set and get the input texture"}),"\n",(0,i.jsx)(t.li,{children:"Automatic binding of the texture to the shader program"}),"\n",(0,i.jsx)(t.li,{children:"Passing texture size to the shader as a uniform"}),"\n"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-kotlin",children:'abstract class TextureInputKraftShader(\n    samplerUniformName: String = "inputImageTexture",\n    sizeUniformName: String = "textureSize",\n) : KraftShader() {\n    // Implementation details\n}\n'})}),"\n",(0,i.jsx)(t.h3,{id:"twotextureinputkraftshader",children:"TwoTextureInputKraftShader"}),"\n",(0,i.jsxs)(t.p,{children:["Extends ",(0,i.jsx)(t.code,{children:"TextureInputKraftShader"})," to support two texture inputs. This is commonly used for blend operations, lookup tables, and other effects that require two images."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-kotlin",children:'abstract class TwoTextureInputKraftShader(\n    samplerUniformName: String = "inputImageTexture",\n    sizeUniformName: String = "textureSize",\n    secondTextureSampleName: String = "inputImageTexture2",\n    secondTextureSizeUniformName: String = "textureSize2",\n) : TextureInputKraftShader(samplerUniformName, sizeUniformName) {\n    // Implementation details\n}\n'})}),"\n",(0,i.jsx)(t.h3,{id:"threetextureinputkraftshader",children:"ThreeTextureInputKraftShader"}),"\n",(0,i.jsxs)(t.p,{children:["Extends ",(0,i.jsx)(t.code,{children:"TwoTextureInputKraftShader"})," to support three texture inputs. This is used for complex effects that require multiple image sources."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-kotlin",children:'abstract class ThreeTextureInputKraftShader(\n    samplerUniformName: String = "inputImageTexture",\n    sizeUniformName: String = "textureSize",\n    secondTextureSampleName: String = "inputImageTexture2",\n    secondTextureSizeUniformName: String = "textureSize2",\n    thirdTextureSampleName: String = "inputImageTexture3",\n    thirdTextureSizeUniformName: String = "textureSize3",\n) : TwoTextureInputKraftShader(\n    // Parameters\n) {\n    // Implementation details\n}\n'})}),"\n",(0,i.jsx)(t.h2,{id:"kraftshadertextureinput",children:"KraftShaderTextureInput"}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"KraftShaderTextureInput"})," class is the core component that manages texture binding and uniform handling for shader texture inputs."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-kotlin",children:'class KraftShaderTextureInput(\n    val textureIndex: Int,\n    samplerUniformName: String = "inputImageTexture${textureIndex + 1}",\n    sizeUniformName: String = "textureSize${textureIndex + 1}",\n    required: Boolean = true,\n) {\n    // Implementation details\n}\n'})}),"\n",(0,i.jsx)(t.p,{children:"Key features:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Manages texture binding to specific texture units"}),"\n",(0,i.jsx)(t.li,{children:"Handles uniform setting for sampler and texture size"}),"\n",(0,i.jsx)(t.li,{children:"Provides a property delegate for texture access"}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"texture-and-textureprovider",children:"Texture and TextureProvider"}),"\n",(0,i.jsx)(t.p,{children:"KraftShade uses two key interfaces for texture management:"}),"\n",(0,i.jsx)(t.h3,{id:"texture",children:"Texture"}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"Texture"})," abstract class represents an OpenGL texture:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-kotlin",children:"abstract class Texture {\n    var textureId: Int\n    abstract val size: GlSize\n    \n    fun isValid(): Boolean\n    suspend fun delete()\n    fun getBitmap(): Bitmap\n    // Other methods\n}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"textureprovider",children:"TextureProvider"}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"TextureProvider"})," interface is used to provide textures to shaders:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-kotlin",children:"fun interface TextureProvider {\n    fun provideTexture(): Texture\n}\n"})}),"\n",(0,i.jsx)(t.p,{children:"This interface allows for dynamic texture generation or loading, making it possible to:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Load textures from assets"}),"\n",(0,i.jsx)(t.li,{children:"Generate textures procedurally"}),"\n",(0,i.jsx)(t.li,{children:"Update textures dynamically"}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"texture-implementations",children:"Texture Implementations"}),"\n",(0,i.jsxs)(t.p,{children:["KraftShade provides several implementations of the ",(0,i.jsx)(t.code,{children:"Texture"})," class:"]}),"\n",(0,i.jsx)(t.h3,{id:"loadedtexture",children:"LoadedTexture"}),"\n",(0,i.jsx)(t.p,{children:"Used for textures loaded from bitmaps:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-kotlin",children:"class LoadedTexture(\n    val name: String? = null\n) : Texture() {\n    fun load(bitmap: Bitmap)\n    // Other methods\n}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"texturebuffer",children:"TextureBuffer"}),"\n",(0,i.jsx)(t.p,{children:"Used for render targets and intermediate textures in a pipeline:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-kotlin",children:"// Example usage\nval textureBuffer = TextureBuffer(GlSize(width, height))\n"})}),"\n",(0,i.jsx)(t.h2,{id:"using-texture-inputs-in-shaders",children:"Using Texture Inputs in Shaders"}),"\n",(0,i.jsx)(t.h3,{id:"basic-usage-with-textureinputkraftshader",children:"Basic Usage with TextureInputKraftShader"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-kotlin",children:'class GrayscaleKraftShader : TextureInputKraftShader() {\n    override fun loadFragmentShader(): String = """\n        precision mediump float;\n        varying vec2 textureCoordinate;\n        uniform sampler2D inputImageTexture;\n        \n        void main() {\n            vec4 color = texture2D(inputImageTexture, textureCoordinate);\n            float gray = dot(color.rgb, vec3(0.299, 0.587, 0.114));\n            gl_FragColor = vec4(vec3(gray), color.a);\n        }\n    """\n}\n'})}),"\n",(0,i.jsx)(t.h3,{id:"using-twotextureinputkraftshader",children:"Using TwoTextureInputKraftShader"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-kotlin",children:'class BlendKraftShader : TwoTextureInputKraftShader() {\n    var mixturePercent: Float by GlUniformDelegate("mixturePercent")\n    \n    init {\n        mixturePercent = 0.5f\n    }\n    \n    override fun loadFragmentShader(): String = """\n        precision mediump float;\n        varying vec2 textureCoordinate;\n        varying vec2 textureCoordinate2;\n        uniform sampler2D inputImageTexture;\n        uniform sampler2D inputImageTexture2;\n        uniform float mixturePercent;\n        \n        void main() {\n            vec4 color1 = texture2D(inputImageTexture, textureCoordinate);\n            vec4 color2 = texture2D(inputImageTexture2, textureCoordinate2);\n            gl_FragColor = mix(color1, color2, mixturePercent);\n        }\n    """\n}\n'})}),"\n",(0,i.jsx)(t.h2,{id:"setting-textures-in-shaders",children:"Setting Textures in Shaders"}),"\n",(0,i.jsx)(t.p,{children:"There are multiple ways to set textures in KraftShade shaders:"}),"\n",(0,i.jsx)(t.h3,{id:"direct-texture-setting",children:"Direct Texture Setting"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-kotlin",children:"val shader = GrayscaleKraftShader()\nshader.setInputTexture(texture)\n"})}),"\n",(0,i.jsx)(t.h3,{id:"using-textureprovider",children:"Using TextureProvider"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-kotlin",children:'val textureProvider = sampledBitmapTextureProvider("myTexture") {\n    // Return a bitmap here\n    loadBitmap()\n}\nshader.setInputTexture(textureProvider)\n'})}),"\n",(0,i.jsx)(t.h3,{id:"in-pipeline-dsl",children:"In Pipeline DSL"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-kotlin",children:"pipeline(targetBuffer) {\n    step(GrayscaleKraftShader()) {\n        // The input texture is automatically set from the previous step\n    }\n    \n    stepWithInputTexture(BlendKraftShader()) {\n        // Set the second texture\n        setSecondInputTexture(someTexture)\n    }\n}\n"})}),"\n",(0,i.jsx)(t.h2,{id:"texture-coordinate-transformation",children:"Texture Coordinate Transformation"}),"\n",(0,i.jsx)(t.p,{children:"TwoTextureInputKraftShader and ThreeTextureInputKraftShader support texture coordinate transformation matrices:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-kotlin",children:"val blendShader = BlendKraftShader()\n\n// Transform the second texture's coordinates\nblendShader.updateTexture2SamplingTransformMatrix {\n    setScale(2.0f, 2.0f)  // Scale the texture coordinates\n    setTranslation(-0.5f, -0.5f)  // Translate the texture coordinates\n}\n"})}),"\n",(0,i.jsx)(t.p,{children:"This is useful for:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Scaling textures"}),"\n",(0,i.jsx)(t.li,{children:"Rotating textures"}),"\n",(0,i.jsx)(t.li,{children:"Translating textures"}),"\n",(0,i.jsx)(t.li,{children:"Creating effects like tiling or mirroring"}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"custom-texture-inputs",children:"Custom Texture Inputs"}),"\n",(0,i.jsxs)(t.p,{children:["While KraftShade provides base classes for shaders with one, two, or three texture inputs, you may need additional texture inputs or want to customize how textures are managed in your shader. The ",(0,i.jsx)(t.code,{children:"KraftShaderTextureInput"})," class allows you to create custom texture inputs for your shaders."]}),"\n",(0,i.jsx)(t.h3,{id:"creating-custom-texture-inputs",children:"Creating Custom Texture Inputs"}),"\n",(0,i.jsx)(t.p,{children:"To add custom texture inputs to your shader:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["Extend one of the base shader classes (typically ",(0,i.jsx)(t.code,{children:"TextureInputKraftShader"}),")"]}),"\n",(0,i.jsxs)(t.li,{children:["Define your custom texture inputs using ",(0,i.jsx)(t.code,{children:"KraftShaderTextureInput"})]}),"\n",(0,i.jsx)(t.li,{children:"Create property delegates for each texture"}),"\n",(0,i.jsx)(t.li,{children:"Add methods to set these textures"}),"\n",(0,i.jsx)(t.li,{children:"Activate the texture inputs before drawing"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Here's an example of a shader with a custom texture input:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-kotlin",children:'class WatermarkShader : TextureInputKraftShader() {\n    // Define uniform properties\n    var opacity: Float by GlUniformDelegate("opacity")\n    \n    // Define custom texture input\n    private val watermarkTextureInput = KraftShaderTextureInput(1, "watermarkTexture")\n    private var _watermarkTexture: Texture by watermarkTextureInput.textureDelegate\n\n    // Methods to set watermark texture\n    fun setWatermarkTexture(texture: Texture) {\n        _watermarkTexture = texture\n    }\n\n    fun setWatermarkTexture(texture: TextureProvider) {\n        _watermarkTexture = texture.provideTexture()\n    }\n\n    override fun loadFragmentShader(): String = """\n        precision mediump float;\n        varying vec2 textureCoordinate;\n        uniform sampler2D inputImageTexture;\n        uniform sampler2D watermarkTexture;\n        uniform float opacity;\n        \n        void main() {\n            vec4 baseColor = texture2D(inputImageTexture, textureCoordinate);\n            vec4 watermark = texture2D(watermarkTexture, textureCoordinate);\n            \n            // Blend the watermark with the base image\n            gl_FragColor = mix(baseColor, watermark, watermark.a * opacity);\n        }\n    """\n\n    // Activate the custom texture input before drawing\n    override fun beforeActualDraw(isScreenCoordinate: Boolean) {\n        super.beforeActualDraw(isScreenCoordinate)\n        watermarkTextureInput.activate()\n    }\n}\n'})}),"\n",(0,i.jsx)(t.h3,{id:"understanding-kraftshadertextureinput",children:"Understanding KraftShaderTextureInput"}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"KraftShaderTextureInput"})," constructor takes these parameters:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-kotlin",children:"KraftShaderTextureInput(\n    textureIndex: Int,          // The texture unit index\n    samplerUniformName: String, // The uniform name in the shader\n    sizeUniformName: String,    // The size uniform name\n    required: Boolean           // Whether this texture is required\n)\n"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"textureIndex"}),": Determines which texture unit (GL_TEXTURE0 + index) will be used. Must be unique within the shader. Valid values range from 0 to 31, though some devices may support fewer."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"samplerUniformName"}),": The name of the sampler uniform in the GLSL shader code. This must match the uniform name in your fragment shader."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"sizeUniformName"}),": The name of the uniform that will receive the texture size. This can be used in shaders that need to know the dimensions of the texture."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"required"}),": Whether this texture is required for the shader to function. If true, the shader will throw an exception if the texture is not set."]}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"using-custom-texture-inputs-in-glsl",children:"Using Custom Texture Inputs in GLSL"}),"\n",(0,i.jsxs)(t.p,{children:["In your fragment shader, declare the sampler uniforms with the same names you used when creating the ",(0,i.jsx)(t.code,{children:"KraftShaderTextureInput"})," instances:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-glsl",children:"precision mediump float;\nvarying vec2 textureCoordinate;\nuniform sampler2D inputImageTexture;  // Base texture from TextureInputKraftShader\nuniform sampler2D watermarkTexture;   // Custom texture input\n\nvoid main() {\n    vec4 baseColor = texture2D(inputImageTexture, textureCoordinate);\n    vec4 watermark = texture2D(watermarkTexture, textureCoordinate);\n    \n    // Use both textures in your shader logic\n    gl_FragColor = mix(baseColor, watermark, watermark.a * 0.5);\n}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"important-considerations",children:"Important Considerations"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Texture Unit Indices"}),": Each texture input must have a unique texture unit index. OpenGL ES supports up to 32 texture units (0-31), but some devices may support fewer."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Activation"}),": Always call ",(0,i.jsx)(t.code,{children:"activate()"})," on each custom texture input in the ",(0,i.jsx)(t.code,{children:"beforeActualDraw()"})," method to ensure textures are bound to the correct texture units."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Texture Delegates"}),": Use the ",(0,i.jsx)(t.code,{children:"textureDelegate"})," property from ",(0,i.jsx)(t.code,{children:"KraftShaderTextureInput"})," to create a property delegate for your texture. This handles the binding and unbinding of textures automatically."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Texture Coordinate Handling"}),": By default, all textures use the same texture coordinates as the main input texture. If you need different coordinates for each texture, you'll need to implement custom vertex shaders."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Memory Management"}),": Ensure textures are properly released when the shader is no longer needed to prevent memory leaks."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsx)(t.h3,{id:"texture-management",children:"Texture Management"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Reuse textures"})," when possible to avoid creating new OpenGL textures"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Delete textures"})," when they are no longer needed to free GPU memory"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Use TextureProvider"})," for dynamic texture generation or loading"]}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Minimize texture size"})," to reduce memory usage and improve performance"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Use appropriate texture formats"})," for your needs"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Consider mipmap generation"})," for textures that will be scaled down"]}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"shader-development",children:"Shader Development"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Use the appropriate base class"})," based on the number of textures needed"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Follow the naming conventions"})," for uniform names"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Handle texture coordinates correctly"})," in your fragment shader"]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"common-pitfalls",children:"Common Pitfalls"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Not binding textures"})," before drawing"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Using incorrect texture coordinates"})," in the fragment shader"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Not handling texture size"})," correctly"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Memory leaks"})," from not deleting textures"]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"related-components",children:"Related Components"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"KraftShader"}),": The base class for all shaders in KraftShade"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"GlUniformDelegate"}),": Used for handling uniform values in shaders"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Pipeline"}),": Used for chaining multiple shader operations"]}),"\n"]})]})}function x(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},8453:(e,t,r)=>{r.d(t,{R:()=>a,x:()=>d});var n=r(6540);const i={},s=n.createContext(i);function a(e){const t=n.useContext(s);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function d(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),n.createElement(s.Provider,{value:t},e.children)}}}]);