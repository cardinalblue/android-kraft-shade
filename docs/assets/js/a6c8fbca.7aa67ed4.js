"use strict";(self.webpackChunkdoc_website=self.webpackChunkdoc_website||[]).push([[1927],{104:(e,s,i)=>{i.r(s),i.d(s,{assets:()=>o,contentTitle:()=>d,default:()=>h,frontMatter:()=>t,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"built-in-shaders/index","title":"Built-in Shaders","description":"Welcome to the Built-in Shaders section of KraftShade documentation. This section covers the pre-built shaders that come with KraftShade, ready to use in your applications.","source":"@site/docs/built-in-shaders/index.md","sourceDirName":"built-in-shaders","slug":"/built-in-shaders/","permalink":"/android-kraft-shade/docs/built-in-shaders/","draft":false,"unlisted":false,"editUrl":"https://github.com/cardinalblue/android-kraft-shade/tree/main/doc_website/docs/built-in-shaders/index.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Best Practices","permalink":"/android-kraft-shade/docs/pipeline-dsl/best-practices"},"next":{"title":"Base Shaders","permalink":"/android-kraft-shade/docs/built-in-shaders/base-shaders"}}');var r=i(4848),a=i(8453);const t={sidebar_position:1},d="Built-in Shaders",o={},l=[{value:"Overview",id:"overview",level:2},{value:"Shader Categories",id:"shader-categories",level:2},{value:"Using Built-in Shaders",id:"using-built-in-shaders",level:2},{value:"Visual Examples",id:"visual-examples",level:2},{value:"Creating Custom Shaders",id:"creating-custom-shaders",level:2},{value:"Shader Composition",id:"shader-composition",level:2},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Related Topics",id:"related-topics",level:2}];function c(e){const s={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.header,{children:(0,r.jsx)(s.h1,{id:"built-in-shaders",children:"Built-in Shaders"})}),"\n",(0,r.jsx)(s.p,{children:"Welcome to the Built-in Shaders section of KraftShade documentation. This section covers the pre-built shaders that come with KraftShade, ready to use in your applications."}),"\n",(0,r.jsx)(s.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsxs)(s.p,{children:["KraftShade provides a comprehensive collection of built-in shaders that cover a wide range of common image processing and visual effects. These shaders are optimized for performance and can be easily combined using the ",(0,r.jsx)(s.a,{href:"../pipeline-dsl",children:"Pipeline DSL"})," to create complex effects."]}),"\n",(0,r.jsx)(s.h2,{id:"shader-categories",children:"Shader Categories"}),"\n",(0,r.jsx)(s.p,{children:"The built-in shaders are organized into several categories:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.a,{href:"./base-shaders",children:"Base Shaders"}),": Fundamental shaders for basic operations"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.a,{href:"./alpha-transparency-effects",children:"Alpha Transparency Effects"}),": Shaders for handling transparency"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.a,{href:"./blending-modes",children:"Blending Modes"}),": Various ways to blend multiple images"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.a,{href:"./blur-distortion",children:"Blur & Distortion"}),": Effects for blurring and distorting images"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.a,{href:"./color-effects",children:"Color Effects"}),": Shaders for color manipulation"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.a,{href:"./convolution-mask-processing",children:"Convolution & Mask Processing"}),": Advanced image processing techniques"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.a,{href:"./edge-detection",children:"Edge Detection"}),": Algorithms for finding edges in images"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.a,{href:"./texture-artistic-effects",children:"Texture & Artistic Effects"}),": Creative and artistic shader effects"]}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"using-built-in-shaders",children:"Using Built-in Shaders"}),"\n",(0,r.jsx)(s.p,{children:"All built-in shaders follow a consistent API and can be used in your pipelines. Each shader is designed to perform a specific visual effect or transformation, and they can be combined in various ways to create complex effects."}),"\n",(0,r.jsxs)(s.p,{children:["For detailed usage examples and code snippets, please refer to the ",(0,r.jsx)(s.a,{href:"./base-shaders",children:"Base Shaders"})," section."]}),"\n",(0,r.jsx)(s.h2,{id:"visual-examples",children:"Visual Examples"}),"\n",(0,r.jsx)(s.p,{children:"Each shader category includes visual examples showing the before and after results of applying different shaders. These examples help you understand the effect of each shader and how it might be used in your applications."}),"\n",(0,r.jsx)(s.p,{children:"[IMAGE: Example shader effects - A grid showing various shader effects applied to the same source image]"}),"\n",(0,r.jsx)(s.h2,{id:"creating-custom-shaders",children:"Creating Custom Shaders"}),"\n",(0,r.jsx)(s.p,{children:"If the built-in shaders don't meet your needs, you can create your own custom shaders by extending the base shader classes:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["Extend ",(0,r.jsx)(s.code,{children:"TextureInputKraftShader"})," for shaders that take a single input texture"]}),"\n",(0,r.jsxs)(s.li,{children:["Extend ",(0,r.jsx)(s.code,{children:"TwoTextureInputKraftShader"})," for shaders that take two input textures"]}),"\n",(0,r.jsxs)(s.li,{children:["Extend ",(0,r.jsx)(s.code,{children:"Sample3x3KraftShader"})," for shaders that need to sample a 3x3 grid of pixels"]}),"\n",(0,r.jsxs)(s.li,{children:["Extend ",(0,r.jsx)(s.code,{children:"Convolution3x3KraftShader"})," for convolution-based shaders"]}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:"Each shader category section includes information about creating custom shaders specific to that category."}),"\n",(0,r.jsx)(s.h2,{id:"shader-composition",children:"Shader Composition"}),"\n",(0,r.jsx)(s.p,{children:"One of KraftShade's strengths is the ability to compose multiple shaders to create complex effects. The Pipeline DSL makes this process straightforward, allowing you to chain shaders together in a readable and maintainable way."}),"\n",(0,r.jsx)(s.p,{children:"For example, you might combine color adjustments like brightness and contrast with artistic effects like vignette to create a specific look for your images or videos."}),"\n",(0,r.jsx)(s.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,r.jsx)(s.p,{children:"When working with shaders, keep these performance considerations in mind:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsx)(s.li,{children:"Some shaders are more computationally expensive than others"}),"\n",(0,r.jsx)(s.li,{children:"Chaining multiple shaders increases processing time"}),"\n",(0,r.jsx)(s.li,{children:"Consider using intermediate buffers for complex multi-pass effects"}),"\n",(0,r.jsx)(s.li,{children:"For real-time applications, test performance on target devices"}),"\n"]}),"\n",(0,r.jsx)(s.h2,{id:"related-topics",children:"Related Topics"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.a,{href:"../core-components",children:"Core Components"}),": Learn about the fundamental building blocks of KraftShade"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.a,{href:"../core-components/shader-system/kraft-shader",children:"KraftShader"}),": Understand the base shader class"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.a,{href:"../pipeline-dsl",children:"Pipeline DSL"}),": Learn how to combine shaders into pipelines"]}),"\n",(0,r.jsxs)(s.li,{children:[(0,r.jsx)(s.a,{href:"../core-components/pipeline-system/buffer-management",children:"Buffer Management"}),": Understand how buffers are managed in multi-pass effects"]}),"\n"]})]})}function h(e={}){const{wrapper:s}={...(0,a.R)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453:(e,s,i)=>{i.d(s,{R:()=>t,x:()=>d});var n=i(6540);const r={},a=n.createContext(r);function t(e){const s=n.useContext(a);return n.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function d(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:t(e.components),n.createElement(a.Provider,{value:s},e.children)}}}]);