"use strict";(self.webpackChunkdoc_website=self.webpackChunkdoc_website||[]).push([[7878],{6273:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>o,contentTitle:()=>r,default:()=>h,frontMatter:()=>d,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"built-in-shaders/edge-detection","title":"Edge Detection","description":"Edge detection shaders in KraftShade identify and highlight boundaries between different regions in an image, which is essential for feature extraction, object recognition, and artistic effects.","source":"@site/docs/built-in-shaders/edge-detection.md","sourceDirName":"built-in-shaders","slug":"/built-in-shaders/edge-detection","permalink":"/android-kraft-shade/docs/built-in-shaders/edge-detection","draft":false,"unlisted":false,"editUrl":"https://github.com/cardinalblue/android-kraft-shade/tree/main/doc_website/docs/built-in-shaders/edge-detection.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"Texture & Artistic Effects","permalink":"/android-kraft-shade/docs/built-in-shaders/texture-artistic-effects"},"next":{"title":"Convolution & Mask Processing","permalink":"/android-kraft-shade/docs/built-in-shaders/convolution-mask-processing"}}');var a=n(4848),s=n(8453);const d={sidebar_position:5},r="Edge Detection",o={},l=[{value:"Overview",id:"overview",level:2},{value:"Available Edge Detection Shaders",id:"available-edge-detection-shaders",level:2},{value:"SobelEdgeDetectionKraftShader",id:"sobeledgedetectionkraftshader",level:3},{value:"DirectionalSobelEdgeDetectionKraftShader",id:"directionalsobeledgedetectionkraftshader",level:3},{value:"Laplacian-Based Edge Detection",id:"laplacian-based-edge-detection",level:2},{value:"LaplacianKraftShader",id:"laplaciankraftshader",level:3},{value:"LaplacianMagnitudeKraftShader",id:"laplacianmagnitudekraftshader",level:3},{value:"Using Edge Detection in Pipelines",id:"using-edge-detection-in-pipelines",level:2},{value:"Edge Overlay",id:"edge-overlay",level:3},{value:"Edge-Aware Blur",id:"edge-aware-blur",level:3},{value:"Customizing Edge Detection",id:"customizing-edge-detection",level:2},{value:"Thresholding After Edge Detection",id:"thresholding-after-edge-detection",level:3},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Advanced Edge Detection Techniques",id:"advanced-edge-detection-techniques",level:2},{value:"Canny Edge Detection",id:"canny-edge-detection",level:3},{value:"Related Topics",id:"related-topics",level:2}];function c(e){const i={a:"a",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(i.header,{children:(0,a.jsx)(i.h1,{id:"edge-detection",children:"Edge Detection"})}),"\n",(0,a.jsx)(i.p,{children:"Edge detection shaders in KraftShade identify and highlight boundaries between different regions in an image, which is essential for feature extraction, object recognition, and artistic effects."}),"\n",(0,a.jsx)(i.h2,{id:"overview",children:"Overview"}),"\n",(0,a.jsx)(i.p,{children:"Edge detection is a fundamental image processing technique that identifies points in an image where the brightness changes sharply or has discontinuities. These points typically organize into a set of curved line segments called edges. Edge detection is widely used in computer vision, image analysis, and for creating artistic effects."}),"\n",(0,a.jsx)(i.p,{children:"KraftShade provides several edge detection shaders that implement different algorithms, each with its own characteristics and use cases."}),"\n",(0,a.jsx)(i.h2,{id:"available-edge-detection-shaders",children:"Available Edge Detection Shaders"}),"\n",(0,a.jsx)(i.h3,{id:"sobeledgedetectionkraftshader",children:"SobelEdgeDetectionKraftShader"}),"\n",(0,a.jsx)(i.p,{children:"Implements the Sobel operator, a classic edge detection algorithm that computes the gradient magnitude of the image intensity function. It highlights areas of high spatial frequency that correspond to edges."}),"\n",(0,a.jsxs)(i.p,{children:[(0,a.jsx)(i.strong,{children:"How It Works:"}),"\nThe Sobel operator uses two 3\xd73 kernels which are convolved with the original image to calculate approximations of the derivatives - one for horizontal changes, and one for vertical. For each pixel, the resulting gradient approximations are combined to give the gradient magnitude."]}),"\n",(0,a.jsx)(i.p,{children:(0,a.jsx)(i.strong,{children:"Example Use Cases:"})}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Feature extraction in computer vision"}),"\n",(0,a.jsx)(i.li,{children:"Creating outline or sketch effects"}),"\n",(0,a.jsx)(i.li,{children:"Preprocessing for object recognition"}),"\n",(0,a.jsx)(i.li,{children:"Artistic edge highlighting"}),"\n"]}),"\n",(0,a.jsx)(i.p,{children:"[IMAGE: SobelEdgeDetectionKraftShader - Left side shows original image, right side shows image with Sobel edge detection applied]"}),"\n",(0,a.jsx)(i.h3,{id:"directionalsobeledgedetectionkraftshader",children:"DirectionalSobelEdgeDetectionKraftShader"}),"\n",(0,a.jsx)(i.p,{children:"An extension of the Sobel operator that preserves the directional information of edges, not just their magnitude. This provides more detailed edge information, including the orientation of edges."}),"\n",(0,a.jsxs)(i.p,{children:[(0,a.jsx)(i.strong,{children:"How It Works:"}),"\nSimilar to the standard Sobel operator, but instead of combining the horizontal and vertical gradients into a single magnitude, it preserves both components. This allows for distinguishing between horizontal, vertical, and diagonal edges."]}),"\n",(0,a.jsx)(i.p,{children:(0,a.jsx)(i.strong,{children:"Example Use Cases:"})}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Advanced feature extraction"}),"\n",(0,a.jsx)(i.li,{children:"Direction-aware edge processing"}),"\n",(0,a.jsx)(i.li,{children:"Creating effects that depend on edge orientation"}),"\n",(0,a.jsx)(i.li,{children:"Pattern recognition"}),"\n"]}),"\n",(0,a.jsx)(i.p,{children:"[IMAGE: DirectionalSobelEdgeDetectionKraftShader - Left side shows original image, right side shows image with directional Sobel edge detection applied]"}),"\n",(0,a.jsx)(i.h2,{id:"laplacian-based-edge-detection",children:"Laplacian-Based Edge Detection"}),"\n",(0,a.jsxs)(i.p,{children:["While covered in the ",(0,a.jsx)(i.a,{href:"./convolution-mask-processing",children:"Convolution & Mask Processing"})," section, it's worth mentioning that KraftShade also provides Laplacian-based edge detection:"]}),"\n",(0,a.jsx)(i.h3,{id:"laplaciankraftshader",children:"LaplacianKraftShader"}),"\n",(0,a.jsx)(i.p,{children:"Uses the Laplacian operator to detect edges by finding areas where the second derivative of the image intensity has a zero crossing."}),"\n",(0,a.jsx)(i.p,{children:"[IMAGE: LaplacianKraftShader - Left side shows original image, right side shows image with Laplacian edge detection applied]"}),"\n",(0,a.jsx)(i.h3,{id:"laplacianmagnitudekraftshader",children:"LaplacianMagnitudeKraftShader"}),"\n",(0,a.jsx)(i.p,{children:"Calculates the magnitude of the Laplacian to detect edges regardless of direction."}),"\n",(0,a.jsx)(i.p,{children:"[IMAGE: LaplacianMagnitudeKraftShader - Left side shows original image, right side shows image with Laplacian magnitude edge detection applied]"}),"\n",(0,a.jsx)(i.h2,{id:"using-edge-detection-in-pipelines",children:"Using Edge Detection in Pipelines"}),"\n",(0,a.jsx)(i.p,{children:"Edge detection shaders are often used as part of a larger image processing pipeline. They can be combined with other effects to create more sophisticated visual results."}),"\n",(0,a.jsx)(i.h3,{id:"edge-overlay",children:"Edge Overlay"}),"\n",(0,a.jsx)(i.p,{children:"Detect edges and overlay them on the original image to create a highlighted edge effect."}),"\n",(0,a.jsx)(i.p,{children:"[IMAGE: Edge Overlay - Left side shows original image, middle shows detected edges, right side shows original with edges overlaid]"}),"\n",(0,a.jsx)(i.h3,{id:"edge-aware-blur",children:"Edge-Aware Blur"}),"\n",(0,a.jsx)(i.p,{children:"Apply blur that preserves edges to create a smooth image that maintains important details."}),"\n",(0,a.jsx)(i.p,{children:"[IMAGE: Edge-Aware Blur - Left side shows original image, right side shows image with edge-aware blur applied]"}),"\n",(0,a.jsx)(i.h2,{id:"customizing-edge-detection",children:"Customizing Edge Detection"}),"\n",(0,a.jsx)(i.p,{children:"You can customize edge detection by adjusting the threshold or sensitivity to create different visual effects:"}),"\n",(0,a.jsx)(i.h3,{id:"thresholding-after-edge-detection",children:"Thresholding After Edge Detection"}),"\n",(0,a.jsx)(i.p,{children:"Apply a threshold to the edge detection result to create binary edges (black and white only)."}),"\n",(0,a.jsx)(i.p,{children:"[IMAGE: Thresholded Edges - Left side shows original edge detection result, right side shows thresholded binary edges]"}),"\n",(0,a.jsx)(i.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,a.jsx)(i.p,{children:"When working with edge detection:"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"Edge detection shaders typically involve convolution operations, which can be computationally expensive"}),"\n",(0,a.jsx)(i.li,{children:"Consider applying edge detection at a lower resolution for better performance"}),"\n",(0,a.jsx)(i.li,{children:"For real-time applications, the Sobel operator is generally more efficient than Laplacian-based methods"}),"\n",(0,a.jsx)(i.li,{children:"Pre-processing with a slight blur can help reduce noise and improve edge detection results"}),"\n"]}),"\n",(0,a.jsx)(i.h2,{id:"advanced-edge-detection-techniques",children:"Advanced Edge Detection Techniques"}),"\n",(0,a.jsx)(i.p,{children:"While KraftShade provides the most common edge detection algorithms, you can implement more advanced techniques by combining existing shaders or creating custom ones:"}),"\n",(0,a.jsx)(i.h3,{id:"canny-edge-detection",children:"Canny Edge Detection"}),"\n",(0,a.jsx)(i.p,{children:"The Canny edge detector is a multi-stage algorithm that can be approximated by combining several KraftShade shaders:"}),"\n",(0,a.jsxs)(i.ol,{children:["\n",(0,a.jsx)(i.li,{children:"Apply Gaussian blur to reduce noise"}),"\n",(0,a.jsx)(i.li,{children:"Apply Sobel edge detection"}),"\n",(0,a.jsx)(i.li,{children:"Apply non-maximum suppression (can be implemented with a custom shader)"}),"\n",(0,a.jsx)(i.li,{children:"Apply hysteresis thresholding (can be implemented with multiple passes and thresholds)"}),"\n"]}),"\n",(0,a.jsx)(i.p,{children:"[IMAGE: Canny Edge Detection - Left side shows original image, right side shows image with Canny edge detection applied]"}),"\n",(0,a.jsx)(i.h2,{id:"related-topics",children:"Related Topics"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.a,{href:"./convolution-mask-processing",children:"Convolution & Mask Processing"}),": Learn about kernel-based image processing"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.a,{href:"./texture-artistic-effects",children:"Texture & Artistic Effects"}),": Combine edge detection with artistic effects"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.a,{href:"../pipeline-dsl",children:"Pipeline DSL"}),": See how to combine shaders into complex effects"]}),"\n"]})]})}function h(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,a.jsx)(i,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>d,x:()=>r});var t=n(6540);const a={},s=t.createContext(a);function d(e){const i=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function r(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:d(e.components),t.createElement(s.Provider,{value:i},e.children)}}}]);