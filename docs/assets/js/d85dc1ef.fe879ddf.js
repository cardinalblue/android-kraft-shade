"use strict";(self.webpackChunkdoc_website=self.webpackChunkdoc_website||[]).push([[9665],{3876:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>l,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"getting-started/basic-concepts","title":"Basic Concepts","description":"This guide introduces the key concepts and terminology used in KraftShade. Understanding these concepts will help you build more complex and efficient graphics applications.","source":"@site/docs/getting-started/basic-concepts.md","sourceDirName":"getting-started","slug":"/getting-started/basic-concepts","permalink":"/android-kraft-shade/docs/getting-started/basic-concepts","draft":false,"unlisted":false,"editUrl":"https://github.com/cardinalblue/android-kraft-shade/tree/main/doc_website/docs/getting-started/basic-concepts.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Quick Start Guide","permalink":"/android-kraft-shade/docs/getting-started/quick-start-guide"},"next":{"title":"first-effect","permalink":"/android-kraft-shade/docs/getting-started/first-effect"}}');var r=s(4848),t=s(8453);const l={sidebar_position:3},a="Basic Concepts",d={},o=[{value:"Core Architecture",id:"core-architecture",level:2},{value:"GlEnv (Graphics Environment)",id:"glenv-graphics-environment",level:3},{value:"Shader System",id:"shader-system",level:3},{value:"Pipeline System",id:"pipeline-system",level:3},{value:"Input System",id:"input-system",level:3},{value:"View Components",id:"view-components",level:3},{value:"Key Concepts",id:"key-concepts",level:2},{value:"Shaders",id:"shaders",level:3},{value:"Textures and Buffers",id:"textures-and-buffers",level:3},{value:"Pipeline DSL",id:"pipeline-dsl",level:3},{value:"Pipeline Execution Flow",id:"pipeline-execution-flow",level:3},{value:"Effect Serialization",id:"effect-serialization",level:3},{value:"Common Shader Types",id:"common-shader-types",level:2},{value:"Next Steps",id:"next-steps",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"basic-concepts",children:"Basic Concepts"})}),"\n",(0,r.jsx)(n.p,{children:"This guide introduces the key concepts and terminology used in KraftShade. Understanding these concepts will help you build more complex and efficient graphics applications."}),"\n",(0,r.jsx)(n.h2,{id:"core-architecture",children:"Core Architecture"}),"\n",(0,r.jsx)(n.p,{children:"KraftShade is built around several key architectural components that work together to provide a flexible and powerful graphics rendering system."}),"\n",(0,r.jsx)(n.h3,{id:"glenv-graphics-environment",children:"GlEnv (Graphics Environment)"}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"GlEnv"})," is the foundation of KraftShade's rendering system:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"It encapsulates all OpenGL ES environment setup in a single class"}),"\n",(0,r.jsx)(n.li,{children:"Creates a dedicated thread dispatcher and binds the GLES context to that thread"}),"\n",(0,r.jsx)(n.li,{children:"Ensures all OpenGL operations run in the correct context"}),"\n",(0,r.jsx)(n.li,{children:"Manages the lifecycle of OpenGL resources"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"shader-system",children:"Shader System"}),"\n",(0,r.jsx)(n.p,{children:"The shader system is responsible for executing graphics operations:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"KraftShader"}),": The base shader implementation that provides a modern Kotlin interface to OpenGL shaders"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"GlUniformDelegate"}),": Handles shader uniform variables with features like:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Support for multiple types (Int, Float, FloatArray, GlMat2/3/4)"}),"\n",(0,r.jsx)(n.li,{children:"Deferred location query and value setting"}),"\n",(0,r.jsx)(n.li,{children:"Optional uniforms support (useful for base class implementations)"}),"\n",(0,r.jsx)(n.li,{children:"Automatic GLES API selection for value binding"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Texture Inputs"}),": Simplified management of texture inputs to shaders"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"pipeline-system",children:"Pipeline System"}),"\n",(0,r.jsx)(n.p,{children:"The pipeline system orchestrates the execution of multiple shaders:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Pipeline"}),": A container for a sequence of shader operations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"PipelineRunContext"}),": Maintains state during pipeline execution"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Buffer Management"}),": Handles intermediate buffers and resource recycling"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"input-system",children:"Input System"}),"\n",(0,r.jsx)(n.p,{children:"The input system provides a flexible way to feed data into shaders:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Input<T>"}),": Base input type for shader parameters"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"SampledInput<T>"}),": Dynamic input handling for values that change over time"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"TimeInput"}),": Time-based animations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"MappedInput"}),": Value transformations"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"view-components",children:"View Components"}),"\n",(0,r.jsx)(n.p,{children:"KraftShade provides ready-to-use view components for both traditional Android Views and Jetpack Compose:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Android Views"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"KraftTextureView"}),": Base OpenGL rendering view"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"KraftEffectTextureView"}),": Effect-enabled view"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"AnimatedKraftTextureView"}),": Animation support with Choreographer"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Jetpack Compose Integration"}),":","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"KraftShadeView"}),": Compose wrapper for KraftTextureView"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"KraftShadeEffectView"}),": Compose wrapper for KraftEffectTextureView"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"KraftShadeAnimatedView"}),": Compose wrapper for AnimatedKraftTextureView"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,r.jsx)(n.h3,{id:"shaders",children:"Shaders"}),"\n",(0,r.jsx)(n.p,{children:"In KraftShade, shaders are the building blocks of visual effects:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"KraftShader"}),": The base class for all shaders"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Shader Parameters"}),": Properties that control the behavior of a shader"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Texture Inputs"}),": Images or buffers that a shader processes"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Bypassable Shaders"}),": Shaders that can be conditionally enabled or disabled"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"textures-and-buffers",children:"Textures and Buffers"}),"\n",(0,r.jsx)(n.p,{children:"KraftShade uses textures and buffers to manage image data:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Texture"}),": An image stored in GPU memory"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"TextureProvider"}),": A source of texture data"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"GlBufferProvider"}),": A target for rendering operations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"TextureBufferPool"}),": Manages reusable texture buffers for efficient memory usage"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"pipeline-dsl",children:"Pipeline DSL"}),"\n",(0,r.jsx)(n.p,{children:"KraftShade provides a Domain-Specific Language (DSL) for building rendering pipelines:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Serial Pipeline"}),": A linear sequence of shader operations"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Graph Pipeline"}),": A complex network of shader operations with flexible input/output connections"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Nested Pipeline"}),": A combination of serial and graph pipelines for complex effects"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"pipeline-execution-flow",children:"Pipeline Execution Flow"}),"\n",(0,r.jsx)(n.p,{children:"The typical flow for executing a pipeline in KraftShade is:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Input Updates"}),": Sample values from ViewModel or MutableState in Compose UI"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Reset PipelineRunContext"}),": Initialize the state for the current frame"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Execute Pipeline Steps"}),": Iterate through steps in the pipeline:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Render to intermediate buffers or the final target buffer"}),"\n",(0,r.jsx)(n.li,{children:"Get values from input and set them as parameters of the shader"}),"\n",(0,r.jsx)(n.li,{children:"Run the shader to render to the target buffer for the step"}),"\n",(0,r.jsx)(n.li,{children:"Automatically recycle buffers that are no longer needed"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"effect-serialization",children:"Effect Serialization"}),"\n",(0,r.jsx)(n.p,{children:"KraftShade allows you to serialize and deserialize effects:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"EffectSerializer"}),": Converts pipeline setups into JSON format"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"SerializedEffect"}),": Reconstructs effects from JSON"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Texture Provider Mapping"}),": Maps texture names to TextureProvider instances"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"common-shader-types",children:"Common Shader Types"}),"\n",(0,r.jsx)(n.p,{children:"KraftShade includes several categories of built-in shaders:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Base Shaders"}),": Core shader implementations like TextureInputKraftShader"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Color Effects"}),": Shaders for color manipulation like SaturationKraftShader"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Alpha & Transparency Effects"}),": Shaders for transparency like AlphaBlendKraftShader"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Texture & Artistic Effects"}),": Shaders for artistic effects like CrosshatchKraftShader"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Edge Detection"}),": Shaders for edge detection like SobelEdgeDetectionKraftShader"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Convolution & Mask Processing"}),": Shaders for convolution operations like Convolution3x3KraftShader"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Blending Modes"}),": Shaders for blending operations like MultiplyBlendKraftShader"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Blur & Distortion"}),": Shaders for blur and distortion effects like CircularBlurKraftShader"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,r.jsx)(n.p,{children:"Now that you understand the basic concepts of KraftShade, you can:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Create your ",(0,r.jsx)(n.a,{href:"./first-effect",children:"First Effect"})," with KraftShade"]}),"\n",(0,r.jsxs)(n.li,{children:["Explore the ",(0,r.jsx)(n.a,{href:"../core-components",children:"Core Components"})," in more detail"]}),"\n",(0,r.jsxs)(n.li,{children:["Learn about the ",(0,r.jsx)(n.a,{href:"../pipeline-dsl",children:"Pipeline DSL"})," for building complex effects"]}),"\n",(0,r.jsxs)(n.li,{children:["Check out the ",(0,r.jsx)(n.a,{href:"../built-in-shaders",children:"Built-in Shaders"})," for ready-to-use effects"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>l,x:()=>a});var i=s(6540);const r={},t=i.createContext(r);function l(e){const n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);