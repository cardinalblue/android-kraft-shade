"use strict";(self.webpackChunkdoc_website=self.webpackChunkdoc_website||[]).push([[5516],{8453:(e,r,n)=>{n.d(r,{R:()=>i,x:()=>d});var s=n(6540);const a={},t=s.createContext(a);function i(e){const r=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function d(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),s.createElement(t.Provider,{value:r},e.children)}},8917:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>l,contentTitle:()=>d,default:()=>c,frontMatter:()=>i,metadata:()=>s,toc:()=>h});const s=JSON.parse('{"id":"core-components/shader-system/kraft-shader","title":"KraftShader","description":"The KraftShader class is the foundation of KraftShade\'s shader system. It provides a flexible and powerful abstraction over OpenGL shader programs, handling the complexities of shader compilation, parameter management, and rendering.","source":"@site/docs/core-components/shader-system/kraft-shader.md","sourceDirName":"core-components/shader-system","slug":"/core-components/shader-system/kraft-shader","permalink":"/android-kraft-shade/docs/core-components/shader-system/kraft-shader","draft":false,"unlisted":false,"editUrl":"https://github.com/cardinalblue/android-kraft-shade/tree/main/doc_website/docs/core-components/shader-system/kraft-shader.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"GlEnv (Graphics Environment)","permalink":"/android-kraft-shade/docs/core-components/glenv"},"next":{"title":"GlUniformDelegate","permalink":"/android-kraft-shade/docs/core-components/shader-system/gl-uniform-delegate"}}');var a=n(4848),t=n(8453);const i={sidebar_position:1},d="KraftShader",l={},h=[{value:"Shader Types",id:"shader-types",level:2},{value:"Shader Execution Flow",id:"shader-execution-flow",level:2},{value:"Key Steps in the Draw Process",id:"key-steps-in-the-draw-process",level:3},{value:"Parameter Handling",id:"parameter-handling",level:2},{value:"Example: OpacityKraftShader",id:"example-opacitykraftshader",level:2},{value:"Behind the Scenes Process",id:"behind-the-scenes-process",level:3},{value:"Creating Custom Shaders",id:"creating-custom-shaders",level:2},{value:"Key Methods",id:"key-methods",level:2}];function o(e){const r={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(r.header,{children:(0,a.jsx)(r.h1,{id:"kraftshader",children:"KraftShader"})}),"\n",(0,a.jsxs)(r.p,{children:["The ",(0,a.jsx)(r.code,{children:"KraftShader"})," class is the foundation of KraftShade's shader system. It provides a flexible and powerful abstraction over OpenGL shader programs, handling the complexities of shader compilation, parameter management, and rendering."]}),"\n",(0,a.jsx)(r.h2,{id:"shader-types",children:"Shader Types"}),"\n",(0,a.jsxs)(r.p,{children:["KraftShade provides several types of shaders that extend the base ",(0,a.jsx)(r.code,{children:"KraftShader"})," class:"]}),"\n",(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"KraftShader"}),": Abstract base class for all shaders"]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"TextureInputKraftShader"}),": Base class for shaders that take a texture input"]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"TwoTextureInputKraftShader"}),": Base class for shaders that take two texture inputs"]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"ThreeTextureInputKraftShader"}),": Base class for shaders that take three texture inputs"]}),"\n"]}),"\n",(0,a.jsxs)(r.p,{children:["For more information about texture handling in shaders, see the ",(0,a.jsx)(r.a,{href:"/android-kraft-shade/docs/core-components/shader-system/texture-inputs",children:"Texture Inputs documentation"}),"."]}),"\n",(0,a.jsx)(r.h2,{id:"shader-execution-flow",children:"Shader Execution Flow"}),"\n",(0,a.jsx)(r.p,{children:"The following sequence diagram illustrates the flow of a shader's draw operation:"}),"\n",(0,a.jsx)(r.mermaid,{value:"sequenceDiagram\n    participant Client\n    participant KraftShader\n    participant GlUniformDelegate\n    participant OpenGL\n\n    Client->>KraftShader: draw(bufferSize, isScreenCoordinate)\n    \n    alt First draw call\n        KraftShader->>KraftShader: init()\n        KraftShader->>OpenGL: loadProgram(vertexShader, fragmentShader)\n        OpenGL--\x3e>KraftShader: glProgId\n    end\n    \n    KraftShader->>OpenGL: glUseProgram(glProgId)\n    KraftShader->>KraftShader: updateTexelSize()\n    KraftShader->>KraftShader: beforeActualDraw(isScreenCoordinate)\n    KraftShader->>KraftShader: runPendingOnDrawTasks()\n    \n    loop For each pending task\n        KraftShader->>GlUniformDelegate: Execute task\n        GlUniformDelegate->>OpenGL: Set uniform values (glUniform*)\n    end\n    \n    KraftShader->>KraftShader: actualDraw(isScreenCoordinate)\n    KraftShader->>OpenGL: glDrawArrays(GL_TRIANGLE_STRIP, 0, 4)\n    KraftShader->>KraftShader: afterActualDraw()"}),"\n",(0,a.jsx)(r.h3,{id:"key-steps-in-the-draw-process",children:"Key Steps in the Draw Process"}),"\n",(0,a.jsxs)(r.ol,{children:["\n",(0,a.jsxs)(r.li,{children:["\n",(0,a.jsxs)(r.p,{children:[(0,a.jsx)(r.strong,{children:"Initialization (First Draw Only)"}),":"]}),"\n",(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsxs)(r.li,{children:["The ",(0,a.jsx)(r.code,{children:"init()"})," method is called on the first draw to compile and link the shader program"]}),"\n",(0,a.jsx)(r.li,{children:"Vertex and fragment shaders are compiled and linked into a program"}),"\n",(0,a.jsx)(r.li,{children:"Attribute locations are retrieved for position and texture coordinates"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(r.li,{children:["\n",(0,a.jsxs)(r.p,{children:[(0,a.jsx)(r.strong,{children:"Program Activation"}),":"]}),"\n",(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsxs)(r.li,{children:["The shader program is activated with ",(0,a.jsx)(r.code,{children:"glUseProgram"})]}),"\n",(0,a.jsx)(r.li,{children:"Resolution uniform is set based on the buffer size"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(r.li,{children:["\n",(0,a.jsxs)(r.p,{children:[(0,a.jsx)(r.strong,{children:"Texture Size Update"}),":"]}),"\n",(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsxs)(r.li,{children:["For shaders that implement ",(0,a.jsx)(r.code,{children:"KraftShaderWithTexelSize"}),", the texel size is updated"]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(r.li,{children:["\n",(0,a.jsxs)(r.p,{children:[(0,a.jsx)(r.strong,{children:"Setup Phase"}),":"]}),"\n",(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.code,{children:"beforeActualDraw"})," sets up textures and vertex attributes"]}),"\n",(0,a.jsx)(r.li,{children:"Texture coordinates are bound to the shader"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(r.li,{children:["\n",(0,a.jsxs)(r.p,{children:[(0,a.jsx)(r.strong,{children:"Parameter Updates"}),":"]}),"\n",(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.code,{children:"runPendingOnDrawTasks"})," executes all queued parameter updates"]}),"\n",(0,a.jsxs)(r.li,{children:["Uniform values are sent to the GPU through ",(0,a.jsx)(r.code,{children:"GlUniformDelegate"})]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(r.li,{children:["\n",(0,a.jsxs)(r.p,{children:[(0,a.jsx)(r.strong,{children:"Rendering"}),":"]}),"\n",(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.code,{children:"actualDraw"})," performs the rendering with the updated parameters"]}),"\n",(0,a.jsx)(r.li,{children:"Vertex positions are bound and the draw call is made"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(r.li,{children:["\n",(0,a.jsxs)(r.p,{children:[(0,a.jsx)(r.strong,{children:"Cleanup"}),":"]}),"\n",(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.code,{children:"afterActualDraw"})," cleans up resources and disables vertex arrays"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(r.h2,{id:"parameter-handling",children:"Parameter Handling"}),"\n",(0,a.jsxs)(r.p,{children:["KraftShade uses a property delegate system (",(0,a.jsx)(r.code,{children:"GlUniformDelegate"}),") to manage shader parameters efficiently. This system allows for:"]}),"\n",(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsx)(r.li,{children:"Declarative parameter definition using Kotlin property delegates"}),"\n",(0,a.jsx)(r.li,{children:"Deferred parameter updates that are batched and applied during draw calls"}),"\n",(0,a.jsx)(r.li,{children:"Automatic type conversion for various parameter types (Float, Int, Boolean, vectors, matrices)"}),"\n",(0,a.jsx)(r.li,{children:"Caching of uniform locations for improved performance"}),"\n"]}),"\n",(0,a.jsx)(r.p,{children:"When a shader parameter is updated:"}),"\n",(0,a.jsxs)(r.ol,{children:["\n",(0,a.jsx)(r.li,{children:"The value is stored locally in the delegate"}),"\n",(0,a.jsxs)(r.li,{children:["A task is queued with the shader's ",(0,a.jsx)(r.code,{children:"runOnDraw"})," method"]}),"\n",(0,a.jsx)(r.li,{children:"The shader's properties map is updated for serialization purposes"}),"\n"]}),"\n",(0,a.jsxs)(r.p,{children:["During the draw call, the ",(0,a.jsx)(r.code,{children:"runPendingOnDrawTasks"})," method executes all queued parameter updates, sending the values to the GPU."]}),"\n",(0,a.jsxs)(r.p,{children:["For more details on parameter handling, see the ",(0,a.jsx)(r.a,{href:"/android-kraft-shade/docs/core-components/shader-system/gl-uniform-delegate",children:"GlUniformDelegate documentation"}),"."]}),"\n",(0,a.jsx)(r.h2,{id:"example-opacitykraftshader",children:"Example: OpacityKraftShader"}),"\n",(0,a.jsxs)(r.p,{children:["Let's walk through a real example using the ",(0,a.jsx)(r.code,{children:"OpacityKraftShader"}),", which adjusts the opacity of an image:"]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-kotlin",children:'class OpacityKraftShader(opacity: Float = 1.0f) : TextureInputKraftShader() {\n    var opacity: Float by GlUniformDelegate("opacity")\n\n    init {\n        this.opacity = opacity\n    }\n\n    override fun loadFragmentShader(): String = OPACITY_FRAGMENT_SHADER\n}\n'})}),"\n",(0,a.jsx)(r.p,{children:"The fragment shader implementation:"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-glsl",children:"varying highp vec2 textureCoordinate;\n\nuniform sampler2D inputImageTexture;\nuniform lowp float opacity;\n\nvoid main()\n{\n    lowp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n    \n    gl_FragColor = vec4(textureColor.rgb, textureColor.a * opacity);\n}\n"})}),"\n",(0,a.jsx)(r.h3,{id:"behind-the-scenes-process",children:"Behind the Scenes Process"}),"\n",(0,a.jsxs)(r.ol,{children:["\n",(0,a.jsxs)(r.li,{children:["\n",(0,a.jsxs)(r.p,{children:[(0,a.jsx)(r.strong,{children:"Shader Creation"}),":"]}),"\n",(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsxs)(r.li,{children:["When an ",(0,a.jsx)(r.code,{children:"OpacityKraftShader"})," is created, the ",(0,a.jsx)(r.code,{children:"opacity"})," property is defined using ",(0,a.jsx)(r.code,{children:"GlUniformDelegate"})]}),"\n",(0,a.jsx)(r.li,{children:"The initial opacity value is set in the constructor, but not yet sent to the GPU"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(r.li,{children:["\n",(0,a.jsxs)(r.p,{children:[(0,a.jsx)(r.strong,{children:"Parameter Updates"}),":"]}),"\n",(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsxs)(r.li,{children:["When ",(0,a.jsx)(r.code,{children:"shader.opacity = 0.5f"})," is called:","\n",(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsx)(r.li,{children:"The value is stored in the delegate"}),"\n",(0,a.jsxs)(r.li,{children:["A task is queued with the shader's ",(0,a.jsx)(r.code,{children:"runOnDraw"})," method"]}),"\n",(0,a.jsx)(r.li,{children:"The shader's properties map is updated for serialization purposes"}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(r.li,{children:["\n",(0,a.jsxs)(r.p,{children:[(0,a.jsx)(r.strong,{children:"Draw Execution"}),":"]}),"\n",(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsxs)(r.li,{children:["When ",(0,a.jsx)(r.code,{children:"shader.draw()"})," is called:","\n",(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsxs)(r.li,{children:["If this is the first draw, ",(0,a.jsx)(r.code,{children:"init()"})," is called to compile the shader program"]}),"\n",(0,a.jsxs)(r.li,{children:["The shader program is activated with ",(0,a.jsx)(r.code,{children:"glUseProgram"})]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.code,{children:"beforeActualDraw"})," sets up textures and vertex attributes"]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.code,{children:"runPendingOnDrawTasks"})," executes all queued parameter updates:","\n",(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsxs)(r.li,{children:["The opacity value is sent to the GPU with ",(0,a.jsx)(r.code,{children:"glUniform1f"})]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.code,{children:"actualDraw"})," performs the rendering with the updated parameters"]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.code,{children:"afterActualDraw"})," cleans up resources"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(r.p,{children:"This deferred parameter update mechanism is efficient because:"}),"\n",(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsx)(r.li,{children:"Multiple parameter changes are batched together"}),"\n",(0,a.jsx)(r.li,{children:"Updates only happen when needed (during draw calls)"}),"\n",(0,a.jsx)(r.li,{children:"Redundant updates are avoided by tracking value changes"}),"\n"]}),"\n",(0,a.jsx)(r.h2,{id:"creating-custom-shaders",children:"Creating Custom Shaders"}),"\n",(0,a.jsxs)(r.p,{children:["KraftShade comes with a variety of ",(0,a.jsx)(r.a,{href:"/android-kraft-shade/docs/built-in-shaders/base-shaders",children:"built-in shaders"})," that you can use out of the box. However, you can also create your own custom shaders by extending one of the base shader classes:"]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-kotlin",children:'class MyCustomShader(\n    intensity: Float = 1.0f\n) : TextureInputKraftShader() {\n    var intensity: Float by GlUniformDelegate("intensity")\n\n    init {\n        this.intensity = intensity\n    }\n\n    override fun loadFragmentShader(): String = """\n        varying highp vec2 textureCoordinate;\n        \n        uniform sampler2D inputImageTexture;\n        uniform lowp float intensity;\n        \n        void main() {\n            lowp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n            // Apply custom effect using intensity parameter\n            gl_FragColor = textureColor * intensity;\n        }\n    """\n}\n'})}),"\n",(0,a.jsx)(r.h2,{id:"key-methods",children:"Key Methods"}),"\n",(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"init()"}),": Initializes the shader program by compiling and linking the shaders"]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"draw()"}),": Executes the shader with the current parameters"]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"loadVertexShader()"}),": Returns the vertex shader source code (default provided)"]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"loadFragmentShader()"}),": Returns the fragment shader source code (must be implemented)"]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"runOnDraw()"}),": Queues a task to be executed during the next draw call"]}),"\n",(0,a.jsxs)(r.li,{children:[(0,a.jsx)(r.strong,{children:"destroy()"}),": Cleans up OpenGL resources when the shader is no longer needed"]}),"\n"]})]})}function c(e={}){const{wrapper:r}={...(0,t.R)(),...e.components};return r?(0,a.jsx)(r,{...e,children:(0,a.jsx)(o,{...e})}):o(e)}}}]);