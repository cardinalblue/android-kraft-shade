"use strict";(self.webpackChunkdoc_website=self.webpackChunkdoc_website||[]).push([[6680],{1262:(e,a,r)=>{r.r(a),r.d(a,{assets:()=>l,contentTitle:()=>d,default:()=>c,frontMatter:()=>i,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"built-in-shaders/base-shaders","title":"Base Shaders","description":"Base shaders provide fundamental operations that serve as building blocks for more complex effects in KraftShade.","source":"@site/docs/built-in-shaders/base-shaders.md","sourceDirName":"built-in-shaders","slug":"/built-in-shaders/base-shaders","permalink":"/android-kraft-shade/docs/built-in-shaders/base-shaders","draft":false,"unlisted":false,"editUrl":"https://github.com/cardinalblue/android-kraft-shade/tree/main/doc_website/docs/built-in-shaders/base-shaders.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Built-in Shaders","permalink":"/android-kraft-shade/docs/built-in-shaders/"},"next":{"title":"Color Effects","permalink":"/android-kraft-shade/docs/built-in-shaders/color-effects"}}');var t=r(4848),n=r(8453);const i={sidebar_position:1},d="Base Shaders",l={},o=[{value:"Overview",id:"overview",level:2},{value:"Available Base Shaders",id:"available-base-shaders",level:2},{value:"DrawTextureKraftShader",id:"drawtexturekraftshader",level:3},{value:"Practical Use Cases",id:"practical-use-cases",level:4},{value:"BypassableTextureInputKraftShader",id:"bypassabletextureinputkraftshader",level:3},{value:"BypassableTwoTextureInputKraftShader",id:"bypassabletwotextureinputkraftshader",level:3},{value:"Base Shader Types",id:"base-shader-types",level:2},{value:"TextureInputKraftShader",id:"textureinputkraftshader",level:3},{value:"TwoTextureInputKraftShader",id:"twotextureinputkraftshader",level:3},{value:"Sample3x3KraftShader",id:"sample3x3kraftshader",level:3},{value:"SingleDirectionForTwoPassSamplingKraftShader",id:"singledirectionfortwopasssamplingkraftshader",level:3},{value:"Using Base Shaders in Pipelines",id:"using-base-shaders-in-pipelines",level:2},{value:"Creating Custom Base Shaders",id:"creating-custom-base-shaders",level:2},{value:"Related Topics",id:"related-topics",level:2}];function h(e){const a={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,n.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(a.header,{children:(0,t.jsx)(a.h1,{id:"base-shaders",children:"Base Shaders"})}),"\n",(0,t.jsx)(a.p,{children:"Base shaders provide fundamental operations that serve as building blocks for more complex effects in KraftShade."}),"\n",(0,t.jsx)(a.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsx)(a.p,{children:"Base shaders are the foundation of KraftShade's shader system. They implement essential operations that can be used alone or combined with other shaders to create sophisticated visual effects. These shaders are optimized for performance and follow a consistent API pattern."}),"\n",(0,t.jsx)(a.h2,{id:"available-base-shaders",children:"Available Base Shaders"}),"\n",(0,t.jsx)(a.h3,{id:"drawtexturekraftshader",children:"DrawTextureKraftShader"}),"\n",(0,t.jsx)(a.p,{children:'The simplest shader that draws the input texture to the output. While it appears to do "nothing" in terms of visual effects, it\'s actually quite useful for various purposes including texture positioning, coordinate transformation, and as a building block for more complex effects.'}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-kotlin",children:"// Create a shader that draws the input texture directly\nval shader = DrawTextureKraftShader()\n"})}),"\n",(0,t.jsx)(a.h4,{id:"practical-use-cases",children:"Practical Use Cases"}),"\n",(0,t.jsx)(a.p,{children:(0,t.jsx)(a.strong,{children:"1. Texture Positioning and Transformation"})}),"\n",(0,t.jsxs)(a.p,{children:["You can use ",(0,t.jsx)(a.code,{children:"withTransform"})," to move, scale, rotate, or flip the texture by transforming the sampling coordinates:"]}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-kotlin",children:"// Move texture to a different position\nval shader = DrawTextureKraftShader().withTransform {\n    translate(0.2f, 0.1f) // Move texture right and up\n}\n\n// Scale and rotate texture\nval shader = DrawTextureKraftShader().withTransform {\n    scale(0.8f, 0.8f)     // Scale down to 80%\n    rotate(45f)           // Rotate 45 degrees\n}\n\n// Flip texture horizontally\nval shader = DrawTextureKraftShader().withTransform {\n    scale(-1f, 1f)        // Flip horizontally\n    translate(1f, 0f)     // Adjust position after flip\n}\n"})}),"\n",(0,t.jsx)(a.p,{children:(0,t.jsx)(a.strong,{children:"2. Texture Cropping and Viewport Control"})}),"\n",(0,t.jsx)(a.p,{children:"Transform coordinates to show only a portion of the texture:"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-kotlin",children:"// Show only the center 50% of the texture\nval shader = DrawTextureKraftShader().withTransform {\n    scale(2f, 2f)         // Scale up sampling\n    translate(-0.25f, -0.25f) // Center the crop\n}\n"})}),"\n",(0,t.jsx)(a.p,{children:(0,t.jsx)(a.strong,{children:"3. Testing and Debugging"})}),"\n",(0,t.jsxs)(a.ul,{children:["\n",(0,t.jsxs)(a.li,{children:[(0,t.jsx)(a.strong,{children:"Pipeline Testing"}),": Verify that your pipeline setup is working correctly"]}),"\n",(0,t.jsxs)(a.li,{children:[(0,t.jsx)(a.strong,{children:"Performance Baseline"}),": Measure the overhead of your pipeline without effect processing"]}),"\n",(0,t.jsxs)(a.li,{children:[(0,t.jsx)(a.strong,{children:"Texture Validation"}),": Confirm that textures are loaded and passed correctly through the pipeline"]}),"\n"]}),"\n",(0,t.jsx)(a.p,{children:(0,t.jsx)(a.strong,{children:"4. Conditional Processing"})}),"\n",(0,t.jsx)(a.p,{children:"Use as a fallback when no effects should be applied:"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-kotlin",children:"val shader = if (effectsEnabled) {\n    SaturationKraftShader(saturation = 1.5f)\n} else {\n    DrawTextureKraftShader() // No effect, just draw the texture\n}\n"})}),"\n",(0,t.jsx)(a.h3,{id:"bypassabletextureinputkraftshader",children:"BypassableTextureInputKraftShader"}),"\n",(0,t.jsx)(a.p,{children:"A wrapper shader that can conditionally bypass the wrapped shader's processing. This is useful for enabling/disabling effects dynamically without restructuring your pipeline."}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-kotlin",children:"// Create a saturation shader that can be bypassed\nval saturationShader = SaturationKraftShader(saturation = 1.5f)\nval bypassableShader = BypassableTextureInputKraftShader(\n    wrappedShader = saturationShader,\n    bypass = false // Initially enabled\n)\n\n// Later, to bypass the shader:\nbypassableShader.bypass = true\n"})}),"\n",(0,t.jsx)(a.h3,{id:"bypassabletwotextureinputkraftshader",children:"BypassableTwoTextureInputKraftShader"}),"\n",(0,t.jsxs)(a.p,{children:["Similar to ",(0,t.jsx)(a.code,{children:"BypassableTextureInputKraftShader"}),", but designed for shaders that take two input textures (like blend shaders)."]}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-kotlin",children:"// Create a blend shader that can be bypassed\nval blendShader = MultiplyBlendKraftShader()\nval bypassableShader = BypassableTwoTextureInputKraftShader(\n    wrappedShader = blendShader,\n    bypass = false, // Initially enabled\n    passTexture1 = true // When bypassed, pass the first texture\n)\n"})}),"\n",(0,t.jsx)(a.h2,{id:"base-shader-types",children:"Base Shader Types"}),"\n",(0,t.jsx)(a.p,{children:"KraftShade provides several base shader types that serve as parent classes for more specific shader implementations:"}),"\n",(0,t.jsx)(a.h3,{id:"textureinputkraftshader",children:"TextureInputKraftShader"}),"\n",(0,t.jsx)(a.p,{children:"The most common base shader type that takes a single texture as input and produces a modified output."}),"\n",(0,t.jsx)(a.h3,{id:"twotextureinputkraftshader",children:"TwoTextureInputKraftShader"}),"\n",(0,t.jsx)(a.p,{children:"A base shader type that takes two textures as input, typically used for blending operations."}),"\n",(0,t.jsx)(a.h3,{id:"sample3x3kraftshader",children:"Sample3x3KraftShader"}),"\n",(0,t.jsx)(a.p,{children:"A specialized shader that samples a 3x3 grid of pixels around each pixel in the input texture. This is the foundation for convolution operations, edge detection, and other neighborhood-based effects."}),"\n",(0,t.jsx)(a.h3,{id:"singledirectionfortwopasssamplingkraftshader",children:"SingleDirectionForTwoPassSamplingKraftShader"}),"\n",(0,t.jsx)(a.p,{children:"A specialized shader designed for two-pass operations where each pass processes the image in a different direction (typically horizontal and vertical). This approach is used for separable filters like Gaussian blur for better performance."}),"\n",(0,t.jsx)(a.h2,{id:"using-base-shaders-in-pipelines",children:"Using Base Shaders in Pipelines"}),"\n",(0,t.jsx)(a.p,{children:"Base shaders can be used directly in your rendering pipelines:"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-kotlin",children:"pipeline(targetBuffer) {\n    serialSteps(\n        inputTexture = inputBitmap.asTexture(),\n        targetBuffer = targetBuffer\n    ) {\n        // Use a base shader as a placeholder or for testing\n        step(DrawTextureKraftShader())\n        \n        // Use a bypassable shader for conditional processing\n        val bypassableShader = BypassableTextureInputKraftShader(\n            wrappedShader = SaturationKraftShader(saturation = 1.5f)\n        )\n        step(bypassableShader)\n    }\n}\n"})}),"\n",(0,t.jsx)(a.h2,{id:"creating-custom-base-shaders",children:"Creating Custom Base Shaders"}),"\n",(0,t.jsx)(a.p,{children:"You can extend the base shader types to create your own custom shaders. For example:"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-kotlin",children:'class MyCustomShader : TextureInputKraftShader() {\n    var intensity: Float by GlUniformDelegate("intensity")\n    \n    init {\n        intensity = 1.0f\n    }\n    \n    override fun loadFragmentShader(): String {\n        return """\n            precision mediump float;\n            varying vec2 textureCoordinate;\n            uniform sampler2D inputImageTexture;\n            uniform float intensity;\n            \n            void main() {\n                vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n                // Apply your custom effect here\n                gl_FragColor = textureColor * intensity;\n            }\n        """\n    }\n}\n'})}),"\n",(0,t.jsx)(a.h2,{id:"related-topics",children:"Related Topics"}),"\n",(0,t.jsxs)(a.ul,{children:["\n",(0,t.jsxs)(a.li,{children:[(0,t.jsx)(a.a,{href:"../core-components/shader-system/kraft-shader",children:"KraftShader"}),": Learn about the base shader class"]}),"\n",(0,t.jsxs)(a.li,{children:[(0,t.jsx)(a.a,{href:"../core-components/shader-system/gl-uniform-delegate",children:"GlUniformDelegate"}),": Understand how shader parameters are managed"]}),"\n",(0,t.jsxs)(a.li,{children:[(0,t.jsx)(a.a,{href:"../pipeline-dsl",children:"Pipeline DSL"}),": See how to combine shaders into pipelines"]}),"\n"]})]})}function c(e={}){const{wrapper:a}={...(0,n.R)(),...e.components};return a?(0,t.jsx)(a,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},8453:(e,a,r)=>{r.d(a,{R:()=>i,x:()=>d});var s=r(6540);const t={},n=s.createContext(t);function i(e){const a=s.useContext(n);return s.useMemo(function(){return"function"==typeof e?e(a):{...a,...e}},[a,e])}function d(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),s.createElement(n.Provider,{value:a},e.children)}}}]);