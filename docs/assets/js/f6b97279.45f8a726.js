"use strict";(self.webpackChunkdoc_website=self.webpackChunkdoc_website||[]).push([[779],{7706:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>p,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"pipeline-dsl/graph-pipeline","title":"Graph Pipeline","description":"A Graph Pipeline in KraftShade provides a more flexible approach to shader operations compared to a Serial Pipeline. Instead of a linear sequence, a Graph Pipeline allows you to create complex, non-linear processing flows where you have precise control over the input and output of each step.","source":"@site/docs/pipeline-dsl/graph-pipeline.md","sourceDirName":"pipeline-dsl","slug":"/pipeline-dsl/graph-pipeline","permalink":"/android-kraft-shade/docs/pipeline-dsl/graph-pipeline","draft":false,"unlisted":false,"editUrl":"https://github.com/cardinalblue/android-kraft-shade/tree/main/doc_website/docs/pipeline-dsl/graph-pipeline.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Serial Pipeline","permalink":"/android-kraft-shade/docs/pipeline-dsl/serial-pipeline"},"next":{"title":"Nested Pipeline","permalink":"/android-kraft-shade/docs/pipeline-dsl/nested-pipeline"}}');var t=r(4848),s=r(8453);const a={sidebar_position:3},l="Graph Pipeline",p={},o=[{value:"Understanding Graph Pipelines",id:"understanding-graph-pipelines",level:2},{value:"Creating a Graph Pipeline",id:"creating-a-graph-pipeline",level:2},{value:"Adding Steps to a Graph Pipeline",id:"adding-steps-to-a-graph-pipeline",level:2},{value:"Basic Step",id:"basic-step",level:3},{value:"Step with Input Texture",id:"step-with-input-texture",level:3},{value:"Buffer Management in Graph Pipelines",id:"buffer-management-in-graph-pipelines",level:2},{value:"Custom Run Steps",id:"custom-run-steps",level:2},{value:"Differences from Serial Pipeline",id:"differences-from-serial-pipeline",level:2},{value:"Implementation Details",id:"implementation-details",level:2},{value:"Real-World Example: Two-Pass Blur",id:"real-world-example-two-pass-blur",level:2},{value:"When to Use Graph Pipelines",id:"when-to-use-graph-pipelines",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"graph-pipeline",children:"Graph Pipeline"})}),"\n",(0,t.jsx)(n.p,{children:"A Graph Pipeline in KraftShade provides a more flexible approach to shader operations compared to a Serial Pipeline. Instead of a linear sequence, a Graph Pipeline allows you to create complex, non-linear processing flows where you have precise control over the input and output of each step."}),"\n",(0,t.jsx)(n.h2,{id:"understanding-graph-pipelines",children:"Understanding Graph Pipelines"}),"\n",(0,t.jsx)(n.p,{children:"Graph pipelines are ideal for:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Complex multi-pass rendering techniques"}),"\n",(0,t.jsx)(n.li,{children:"Effects that require intermediate results"}),"\n",(0,t.jsx)(n.li,{children:"Scenarios where you need precise control over buffer management"}),"\n",(0,t.jsx)(n.li,{children:"Advanced compositing operations"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"The key characteristic of a graph pipeline is its non-linear nature - you explicitly define where each step gets its input from and where it renders its output to."}),"\n",(0,t.jsx)(n.h2,{id:"creating-a-graph-pipeline",children:"Creating a Graph Pipeline"}),"\n",(0,t.jsxs)(n.p,{children:["You can create a graph pipeline using the ",(0,t.jsx)(n.code,{children:"graphSteps"})," function within a pipeline context:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"pipeline(windowSurface) {\n    graphSteps(targetBuffer = windowSurface) {\n        // Graph steps defined here\n    }\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"Parameters:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"targetBuffer"}),": The final output buffer where the result will be rendered"]}),"\n",(0,t.jsx)(n.li,{children:"A lambda block where you define the steps of the graph pipeline"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"adding-steps-to-a-graph-pipeline",children:"Adding Steps to a Graph Pipeline"}),"\n",(0,t.jsx)(n.p,{children:"Within a graph pipeline, you have several ways to add steps:"}),"\n",(0,t.jsx)(n.h3,{id:"basic-step",children:"Basic Step"}),"\n",(0,t.jsxs)(n.p,{children:["The most basic way to add a step is with the ",(0,t.jsx)(n.code,{children:"step"})," function:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"graphSteps(targetBuffer = windowSurface) {\n    step(\n        shader = MyCustomShader(),\n        targetBuffer = buffer1,\n        setupAction = { shader ->\n            // Configure shader parameters\n        }\n    )\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"Parameters:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"shader"}),": The shader to use for this step"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"targetBuffer"}),": The buffer to render the output to"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"setupAction"}),": An optional lambda to configure the shader"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"step-with-input-texture",children:"Step with Input Texture"}),"\n",(0,t.jsxs)(n.p,{children:["For shaders that require an input texture, you can use ",(0,t.jsx)(n.code,{children:"stepWithInputTexture"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"graphSteps(targetBuffer = windowSurface) {\n    stepWithInputTexture(\n        shader = BlurKraftShader(),\n        inputTexture = sourceTexture,\n        targetBuffer = buffer1\n    )\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"This method has two variants:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"For constant textures (loaded from a bitmap)"}),"\n",(0,t.jsx)(n.li,{children:"For texture providers (like buffer references)"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"buffer-management-in-graph-pipelines",children:"Buffer Management in Graph Pipelines"}),"\n",(0,t.jsx)(n.p,{children:"One of the key features of graph pipelines is explicit buffer management. You can create buffer references and use them as inputs and outputs for different steps:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'graphSteps(targetBuffer = windowSurface) {\n    // Create buffer references\n    val (horizontalBlurBuffer, verticalBlurBuffer) = createBufferReferences(\n        "horizontal-blur",\n        "vertical-blur"\n    )\n    \n    // First pass: horizontal blur\n    stepWithInputTexture(\n        shader = BlurKraftShader(),\n        inputTexture = sourceTexture,\n        targetBuffer = horizontalBlurBuffer\n    ) { shader ->\n        shader.direction = BlurDirection.HORIZONTAL\n    }\n    \n    // Second pass: vertical blur using the result of the first pass\n    stepWithInputTexture(\n        shader = BlurKraftShader(),\n        inputTexture = horizontalBlurBuffer,\n        targetBuffer = verticalBlurBuffer\n    ) { shader ->\n        shader.direction = BlurDirection.VERTICAL\n    }\n    \n    // Final pass: blend the blurred result with the original\n    stepWithInputTexture(\n        shader = AlphaBlendKraftShader(),\n        inputTexture = sourceTexture,\n        targetBuffer = graphTargetBuffer\n    ) { shader ->\n        shader.setSecondInputTexture(verticalBlurBuffer)\n        shader.mixturePercent = 0.8f\n    }\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"This example demonstrates a two-pass blur effect followed by a blend operation, which would be difficult to express in a serial pipeline."}),"\n",(0,t.jsx)(n.h2,{id:"custom-run-steps",children:"Custom Run Steps"}),"\n",(0,t.jsx)(n.p,{children:"For operations that don't fit the shader model, you can use a custom run step:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'graphSteps(targetBuffer = windowSurface) {\n    step("Custom operation") { runContext ->\n        // Custom OpenGL operations here\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"differences-from-serial-pipeline",children:"Differences from Serial Pipeline"}),"\n",(0,t.jsx)(n.p,{children:"The main differences between graph and serial pipelines are:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Explicit Buffer Management"}),": In a graph pipeline, you explicitly specify the target buffer for each step, while in a serial pipeline, the buffers are managed automatically using a ping-pong mechanism."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Non-Linear Flow"}),": Graph pipelines allow for non-linear processing flows, where steps can use the outputs of any previous step as input, not just the immediately preceding step."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Multiple Inputs"}),": Graph pipelines make it easier to work with shaders that require multiple input textures, such as blend operations."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Reuse of Intermediate Results"}),": You can reuse the output of a step multiple times in different parts of the pipeline."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"implementation-details",children:"Implementation Details"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"GraphPipelineSetupScope"})," class provides the implementation for graph pipelines. It extends ",(0,t.jsx)(n.code,{children:"BasePipelineSetupScope"})," and adds methods specific to graph pipelines:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"@KraftShadeDsl\nclass GraphPipelineSetupScope(\n    glEnv: GlEnv,\n    pipeline: Pipeline,\n    val graphTargetBuffer: GlBufferProvider,\n) : BasePipelineSetupScope(glEnv, pipeline) {\n    // Methods for adding steps to the graph pipeline\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"graphTargetBuffer"})," property represents the final output buffer for the graph pipeline."]}),"\n",(0,t.jsx)(n.h2,{id:"real-world-example-two-pass-blur",children:"Real-World Example: Two-Pass Blur"}),"\n",(0,t.jsx)(n.p,{children:"Here's a complete example that implements a two-pass Gaussian blur effect using a graph pipeline:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'pipeline(windowSurface) {\n    graphSteps(targetBuffer = windowSurface) {\n        // Create buffer references for intermediate results\n        val (horizontalBlurBuffer, verticalBlurBuffer) = createBufferReferences(\n            "horizontal-blur",\n            "vertical-blur"\n        )\n        \n        // First pass: horizontal blur\n        stepWithInputTexture(\n            shader = GaussianBlurKraftShader(),\n            inputTexture = bitmap.asTexture(),\n            targetBuffer = horizontalBlurBuffer\n        ) { shader ->\n            shader.blurSize = 10f\n            shader.horizontal = true\n        }\n        \n        // Second pass: vertical blur\n        stepWithInputTexture(\n            shader = GaussianBlurKraftShader(),\n            inputTexture = horizontalBlurBuffer,\n            targetBuffer = verticalBlurBuffer\n        ) { shader ->\n            shader.blurSize = 10f\n            shader.horizontal = false\n        }\n        \n        // Final pass: apply vignette to the blurred result\n        stepWithInputTexture(\n            shader = VignetteKraftShader(),\n            inputTexture = verticalBlurBuffer,\n            targetBuffer = graphTargetBuffer\n        ) { shader ->\n            shader.vignetteStart = 0.8f\n            shader.vignetteEnd = 0.3f\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"This creates a processing graph that:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Applies a horizontal Gaussian blur to the input image"}),"\n",(0,t.jsx)(n.li,{children:"Applies a vertical Gaussian blur to the result of step 1"}),"\n",(0,t.jsx)(n.li,{children:"Applies a vignette effect to the fully blurred image"}),"\n",(0,t.jsx)(n.li,{children:"Renders the final result to the window surface"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"when-to-use-graph-pipelines",children:"When to Use Graph Pipelines"}),"\n",(0,t.jsx)(n.p,{children:"Consider using graph pipelines when:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"You need to implement multi-pass effects like bloom, depth of field, or shadow mapping"}),"\n",(0,t.jsx)(n.li,{children:"You want to reuse intermediate results in different parts of your pipeline"}),"\n",(0,t.jsx)(n.li,{children:"You need precise control over buffer allocation and management"}),"\n",(0,t.jsx)(n.li,{children:"Your effect requires non-linear processing flows"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["For simpler linear effects, a ",(0,t.jsx)(n.a,{href:"/android-kraft-shade/docs/pipeline-dsl/serial-pipeline",children:"Serial Pipeline"})," might be more appropriate. For complex effects that combine both approaches, consider using a ",(0,t.jsx)(n.a,{href:"/android-kraft-shade/docs/pipeline-dsl/nested-pipeline",children:"Nested Pipeline"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>l});var i=r(6540);const t={},s=i.createContext(t);function a(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);