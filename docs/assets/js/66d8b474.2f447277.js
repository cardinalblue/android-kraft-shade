"use strict";(self.webpackChunkdoc_website=self.webpackChunkdoc_website||[]).push([[6636],{8038:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"introduction/why-kraftshade","title":"Why KraftShade","description":"Understanding GPUImage","source":"@site/docs/introduction/why-kraftshade.md","sourceDirName":"introduction","slug":"/introduction/why-kraftshade","permalink":"/android-kraft-shade/docs/introduction/why-kraftshade","draft":false,"unlisted":false,"editUrl":"https://github.com/cardinalblue/android-kraft-shade/tree/main/doc_website/docs/introduction/why-kraftshade.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Overview","permalink":"/android-kraft-shade/docs/introduction/overview"},"next":{"title":"Architecture Overview","permalink":"/android-kraft-shade/docs/introduction/architecture-overview"}}');var r=i(4848),a=i(8453);const s={sidebar_position:2},l="Why KraftShade",o={},d=[{value:"Understanding GPUImage",id:"understanding-gpuimage",level:2},{value:"Limitations of GPUImage",id:"limitations-of-gpuimage",level:2},{value:"KraftShade&#39;s Advantages",id:"kraftshades-advantages",level:2},{value:"Complex Pipeline Support",id:"complex-pipeline-support",level:3},{value:"Simplified Serial Pipelines",id:"simplified-serial-pipelines",level:3},{value:"Jetpack Compose Integration",id:"jetpack-compose-integration",level:3},{value:"Modern Architecture",id:"modern-architecture",level:3},{value:"When to Choose KraftShade",id:"when-to-choose-kraftshade",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"why-kraftshade",children:"Why KraftShade"})}),"\n",(0,r.jsx)(n.h2,{id:"understanding-gpuimage",children:"Understanding GPUImage"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"https://github.com/CyberAgent/android-gpuimage",children:"GPUImage"})," has been a popular library for applying GPU-accelerated filters to images and videos on Android. It provides a simple way to apply various filters to images and videos using OpenGL ES 2.0."]}),"\n",(0,r.jsx)(n.p,{children:"GPUImage is still quite effective if you only need a simple pipeline that is serial (one filter after another) and all filters take only one input texture. This is achieved through GPUImageFilterGroup, which essentially implements a ping-pong buffer mechanism."}),"\n",(0,r.jsx)(n.p,{children:"For example, a typical GPUImage pipeline might look like this:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-java",children:"GPUImageFilterGroup filterGroup = new GPUImageFilterGroup();\nfilterGroup.addFilter(new GPUImageSaturationFilter(1.5f));\nfilterGroup.addFilter(new GPUImageContrastFilter(1.2f));\nfilterGroup.addFilter(new GPUImageBrightnessFilter(0.1f));\ngpuImage.setFilter(filterGroup);\n"})}),"\n",(0,r.jsx)(n.h2,{id:"limitations-of-gpuimage",children:"Limitations of GPUImage"}),"\n",(0,r.jsx)(n.p,{children:"While GPUImage works well for simple use cases, it has several limitations:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Inflexible Pipeline Architecture"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Limited to single serial pipeline due to its design"}),"\n",(0,r.jsx)(n.li,{children:"Cannot easily reuse the output of a specific shader in multiple steps"}),"\n",(0,r.jsx)(n.li,{children:"No support for complex graph-based pipelines"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Java-centric Design"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Lacks Kotlin idioms and modern language features"}),"\n",(0,r.jsx)(n.li,{children:"No coroutines support for thread (EGLContext) based operations"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Limited View Component Support"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Minimal integration with modern UI frameworks"}),"\n",(0,r.jsx)(n.li,{children:"No built-in support for Jetpack Compose"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Development Challenges"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Insufficient error handling and debugging capabilities"}),"\n",(0,r.jsx)(n.li,{children:"Limited control over resource allocation"}),"\n",(0,r.jsx)(n.li,{children:"No active maintenance since 2021"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"kraftshades-advantages",children:"KraftShade's Advantages"}),"\n",(0,r.jsx)(n.p,{children:"KraftShade was designed to address these limitations while providing a modern, flexible approach to GPU-accelerated graphics on Android."}),"\n",(0,r.jsx)(n.h3,{id:"complex-pipeline-support",children:"Complex Pipeline Support"}),"\n",(0,r.jsx)(n.p,{children:"Unlike GPUImage, KraftShade can create very complex pipelines. It allows you to reuse the output of a specific shader in multiple steps, creating non-linear processing flows that would be difficult or impossible with GPUImage."}),"\n",(0,r.jsx)(n.p,{children:"For example, here's a complex effect pipeline that would be challenging to implement with GPUImage but is straightforward with KraftShade:"}),"\n",(0,r.jsx)(n.mermaid,{value:"graph TD\n  classDef texture fill:#088\n  inputTexture:::texture --\x3e ResizeFilter --\x3e resizedTexture:::texture\n  \n  resizedTexture --\x3e BlurFilter --\x3e blurredTexture:::texture\n  resizedTexture --\x3e EdgeDetectionFilter --\x3e edgesTexture:::texture\n  \n  blurredTexture --\x3e ContrastFilter\n  edgesTexture --\x3e ThresholdFilter\n  \n  ContrastFilter --\x3e OverlayBlendFilter\n  ThresholdFilter --\x3e OverlayBlendFilter\n  OverlayBlendFilter --\x3e SaturationFilter\n  SaturationFilter --\x3e VignetteFilter\n  inputTexture --\x3e AlphaBlendFilter\n  VignetteFilter --\x3e AlphaBlendFilter\n\n  AlphaBlendFilter --\x3e windowSurfaceBuffer:::texture"}),"\n",(0,r.jsx)(n.p,{children:"In this pipeline, the resized texture is used in two separate processing branches, and the results are later combined. This type of non-linear processing is a natural fit for KraftShade's architecture."}),"\n",(0,r.jsx)(n.h3,{id:"simplified-serial-pipelines",children:"Simplified Serial Pipelines"}),"\n",(0,r.jsxs)(n.p,{children:["If you only need a simple serial pipeline like what GPUImage provides, KraftShade offers the ",(0,r.jsx)(n.code,{children:"serialSteps"})," feature to make pipeline configuration easier:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-kotlin",children:"pipeline(windowSurface) {\n    serialSteps(\n        inputTexture = bitmap.asTexture(),\n        targetBuffer = windowSurface,\n    ) {\n        step(SaturationKraftShader()) {\n            saturation = sampledInput { saturation }\n        }\n\n        step(HueKraftShader()) {\n            setHueInDegree(sampledInput { hue })\n        }\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"jetpack-compose-integration",children:"Jetpack Compose Integration"}),"\n",(0,r.jsx)(n.p,{children:"KraftShade provides several Jetpack Compose views that you can easily integrate with your Compose UI:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-kotlin",children:'@Composable\nfun MyEffect() {\n    val state = rememberKraftShadeAnimatedState()\n    var aspectRatio by remember { mutableFloatStateOf(1f) }\n\n    KraftShadeAnimatedView(\n        modifier = Modifier\n            .fillMaxWidth()\n            .aspectRatio(aspectRatio),\n        state = state\n    )\n\n    LaunchedEffect(Unit) {\n        state.setEffectAndPlay { windowSurface, timeInput ->\n            val bitmap = context.loadBitmapFromAsset("sample/cat.jpg")\n            aspectRatio = bitmap.width.toFloat() / bitmap.height\n\n            val saturationInput = timeInput\n                .bounceBetween(0f, 1f)\n\n            pipeline(windowSurface) {\n                serialSteps(bitmap.asTexture(), windowSurface) {\n                    step(SaturationKraftShader()) { shader ->\n                        shader.saturation = saturationInput.get()\n                    }\n                }\n            }\n        }\n    }\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["The animated view gives you access to a ",(0,r.jsx)(n.code,{children:"timeInput"})," parameter that you can use to create time-based animations and effects."]}),"\n",(0,r.jsx)(n.h3,{id:"modern-architecture",children:"Modern Architecture"}),"\n",(0,r.jsx)(n.p,{children:"KraftShade is built with modern Android development in mind:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Kotlin-first design"})," with coroutines support"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Easy to use DSL"})," for pipeline construction"]}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"Type-safe builder pattern"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"Automatic resource cleanup"})}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Efficient buffer management"})," with automatic recycling"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"when-to-choose-kraftshade",children:"When to Choose KraftShade"}),"\n",(0,r.jsx)(n.p,{children:"KraftShade is the right choice when:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"You need complex, non-linear shader pipelines"}),"\n",(0,r.jsx)(n.li,{children:"You want to integrate GPU-accelerated graphics with Jetpack Compose"}),"\n",(0,r.jsx)(n.li,{children:"You need animation support for your effects"}),"\n",(0,r.jsx)(n.li,{children:"You want a modern, Kotlin-first API with coroutines support"}),"\n",(0,r.jsx)(n.li,{children:"You need better debugging and error handling for shader development"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Even for simpler use cases, KraftShade's modern architecture and active development make it a compelling alternative to GPUImage for new Android projects."})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>l});var t=i(6540);const r={},a=t.createContext(r);function s(e){const n=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);