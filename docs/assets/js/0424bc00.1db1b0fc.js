"use strict";(self.webpackChunkdoc_website=self.webpackChunkdoc_website||[]).push([[3756],{3161:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>m,frontMatter:()=>r,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"view-components/jetpack-compose/kraft-shade-animated-view","title":"KraftShadeAnimatedView","description":"KraftShadeAnimatedView is a Jetpack Compose wrapper for AnimatedKraftTextureView, providing animation capabilities for shader effects in Compose UIs.","source":"@site/docs/view-components/jetpack-compose/kraft-shade-animated-view.md","sourceDirName":"view-components/jetpack-compose","slug":"/view-components/jetpack-compose/kraft-shade-animated-view","permalink":"/android-kraft-shade/docs/view-components/jetpack-compose/kraft-shade-animated-view","draft":false,"unlisted":false,"editUrl":"https://github.com/cardinalblue/android-kraft-shade/tree/main/doc_website/docs/view-components/jetpack-compose/kraft-shade-animated-view.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"KraftShadeEffectView","permalink":"/android-kraft-shade/docs/view-components/jetpack-compose/kraft-shade-effect-view"},"next":{"title":"Pipeline DSL","permalink":"/android-kraft-shade/docs/pipeline-dsl/"}}');var i=t(4848),s=t(8453);const r={sidebar_position:3},o="KraftShadeAnimatedView",d={},l=[{value:"Overview",id:"overview",level:2},{value:"Key Features",id:"key-features",level:2},{value:"Basic Usage",id:"basic-usage",level:2},{value:"Components",id:"components",level:2},{value:"KraftShadeAnimatedView Composable",id:"kraftshadeanimatedview-composable",level:3},{value:"KraftShadeAnimatedState",id:"kraftshadeanimatedstate",level:3},{value:"rememberKraftShadeAnimatedState",id:"rememberkraftshadeanimatedstate",level:3},{value:"Example: Complex Animation with Multiple Effects",id:"example-complex-animation-with-multiple-effects",level:2},{value:"Working with TimeInput in Compose",id:"working-with-timeinput-in-compose",level:2},{value:"<code>bounceBetween</code>",id:"bouncebetween",level:3},{value:"<code>map</code>",id:"map",level:3},{value:"Lifecycle Management",id:"lifecycle-management",level:2},{value:"Considerations",id:"considerations",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"kraftshadeanimatedview",children:"KraftShadeAnimatedView"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"KraftShadeAnimatedView"})," is a Jetpack Compose wrapper for ",(0,i.jsx)(n.a,{href:"/android-kraft-shade/docs/view-components/android-views/animated-kraft-texture-view",children:"AnimatedKraftTextureView"}),", providing animation capabilities for shader effects in Compose UIs."]}),"\n",(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"KraftShadeAnimatedView"})," integrates the animation capabilities of ",(0,i.jsx)(n.code,{children:"AnimatedKraftTextureView"})," into Jetpack Compose applications. It builds on the foundation of ",(0,i.jsx)(n.a,{href:"/android-kraft-shade/docs/view-components/jetpack-compose/kraft-shade-effect-view",children:"KraftShadeEffectView"})," and adds functionality specifically for creating time-based animations with shader effects."]}),"\n",(0,i.jsx)(n.p,{children:"This component is ideal for Compose applications that need to create dynamic, animated visual effects that change over time, such as transitions, procedural animations, or time-based visual effects."}),"\n",(0,i.jsx)(n.h2,{id:"key-features",children:"Key Features"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Integrates ",(0,i.jsx)(n.code,{children:"AnimatedKraftTextureView"})," into Jetpack Compose UIs"]}),"\n",(0,i.jsx)(n.li,{children:"Provides a state-based API for managing animated effects"}),"\n",(0,i.jsx)(n.li,{children:"Supports play/pause controls for animation"}),"\n",(0,i.jsxs)(n.li,{children:["Includes a built-in ",(0,i.jsx)(n.code,{children:"TimeInput"})," for time-based animations"]}),"\n",(0,i.jsx)(n.li,{children:"Handles proper resource cleanup with Compose's lifecycle"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,i.jsxs)(n.p,{children:["Here's a simple example of using ",(0,i.jsx)(n.code,{children:"KraftShadeAnimatedView"})," to create an animated saturation effect in a Compose UI:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'@Composable\nfun AnimatedSaturationDemo() {\n    // Create and remember the state\n    val state = rememberKraftShadeAnimatedState()\n    var isPlaying by remember { mutableStateOf(true) }\n    var aspectRatio by remember { mutableFloatStateOf(1f) }\n    val context = LocalContext.current\n    \n    Column(\n        modifier = Modifier.fillMaxSize(),\n        horizontalAlignment = Alignment.CenterHorizontally\n    ) {\n        // Animated view\n        KraftShadeAnimatedView(\n            modifier = Modifier\n                .weight(1f)\n                .aspectRatio(aspectRatio),\n            state = state\n        )\n        \n        // Play/Pause button\n        Button(\n            modifier = Modifier.padding(16.dp),\n            onClick = {\n                if (isPlaying) {\n                    state.stop()\n                } else {\n                    state.play()\n                }\n                isPlaying = !isPlaying\n            }\n        ) {\n            Text(if (isPlaying) "Pause" else "Play")\n        }\n    }\n    \n    // Set up the animated effect\n    LaunchedEffect(Unit) {\n        state.setEffectAndPlay { windowSurface, timeInput ->\n            val bitmap = context.loadBitmapFromAsset("sample/cat.jpg")\n            aspectRatio = bitmap.width.toFloat() / bitmap.height\n            \n            // Create a saturation input that oscillates between 0 and 1\n            val saturationInput = timeInput.bounceBetween(0f, 1f)\n            \n            pipeline(windowSurface) {\n                serialSteps(bitmap.asTexture(), windowSurface) {\n                    step(SaturationKraftShader()) { shader ->\n                        shader.saturation = saturationInput.get()\n                    }\n                }\n            }\n        }\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"components",children:"Components"}),"\n",(0,i.jsx)(n.h3,{id:"kraftshadeanimatedview-composable",children:"KraftShadeAnimatedView Composable"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"@Composable\nfun KraftShadeAnimatedView(\n    modifier: Modifier = Modifier,\n    state: KraftShadeAnimatedState = rememberKraftShadeAnimatedState()\n)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The main Composable function that creates an ",(0,i.jsx)(n.code,{children:"AnimatedKraftTextureView"})," and integrates it into your Compose UI."]}),"\n",(0,i.jsx)(n.p,{children:"Parameters:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"modifier"}),": Standard Compose modifier for customizing the view's layout"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"state"}),": A ",(0,i.jsx)(n.code,{children:"KraftShadeAnimatedState"})," that manages the view's state and operations"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"kraftshadeanimatedstate",children:"KraftShadeAnimatedState"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"class KraftShadeAnimatedState(scope: CoroutineScope)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Manages the state of the ",(0,i.jsx)(n.code,{children:"KraftShadeAnimatedView"})," and provides methods to interact with it."]}),"\n",(0,i.jsx)(n.p,{children:"Key methods:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"setEffectAndPlay(effectExecutionProvider: AnimatedEffectExecutionProvider)"}),": Sets the effect and starts the animation"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"setEffectAndPause(effectExecutionProvider: AnimatedEffectExecutionProvider)"}),": Sets the effect without starting the animation"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"play()"}),": Starts or resumes the animation"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"stop()"}),": Pauses the animation"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"getTimeInput()"}),": Gets the ",(0,i.jsx)(n.code,{children:"TimeInput"})," instance for creating time-based animations"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Properties:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"playing"}),": Indicates whether the animation is currently playing"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"rememberkraftshadeanimatedstate",children:"rememberKraftShadeAnimatedState"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"@Composable\nfun rememberKraftShadeAnimatedState(): KraftShadeAnimatedState\n"})}),"\n",(0,i.jsxs)(n.p,{children:["A Compose helper function that creates and remembers a ",(0,i.jsx)(n.code,{children:"KraftShadeAnimatedState"})," instance, ensuring it survives recomposition."]}),"\n",(0,i.jsx)(n.h2,{id:"example-complex-animation-with-multiple-effects",children:"Example: Complex Animation with Multiple Effects"}),"\n",(0,i.jsx)(n.p,{children:"This example shows how to create a more complex animation with multiple time-based effects:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:'@Composable\nfun ComplexAnimationDemo() {\n    val state = rememberKraftShadeAnimatedState()\n    var aspectRatio by remember { mutableFloatStateOf(1f) }\n    val context = LocalContext.current\n    \n    Column(\n        modifier = Modifier.fillMaxSize(),\n        horizontalAlignment = Alignment.CenterHorizontally\n    ) {\n        // Animated view\n        KraftShadeAnimatedView(\n            modifier = Modifier\n                .weight(1f)\n                .aspectRatio(aspectRatio),\n            state = state\n        )\n        \n        // Control buttons\n        Row(\n            modifier = Modifier.padding(16.dp),\n            horizontalArrangement = Arrangement.SpaceEvenly\n        ) {\n            Button(onClick = { state.play() }) {\n                Text("Play")\n            }\n            \n            Spacer(modifier = Modifier.width(16.dp))\n            \n            Button(onClick = { state.stop() }) {\n                Text("Pause")\n            }\n        }\n    }\n    \n    // Set up the animated effect\n    LaunchedEffect(Unit) {\n        state.setEffectAndPlay { windowSurface, timeInput ->\n            val bitmap = context.loadBitmapFromAsset("sample/cat.jpg")\n            aspectRatio = bitmap.width.toFloat() / bitmap.height\n            \n            // Create multiple time-based inputs with different periods\n            val saturationInput = timeInput.bounceBetween(0.5f, 1.5f, periodMs = 3000)\n            val contrastInput = timeInput.bounceBetween(0.8f, 1.2f, periodMs = 5000)\n            val hueRotationInput = timeInput.map { (it % 10000) / 10000f * 360f }\n            \n            // Create a swirl effect with animated center point\n            val swirlCenterX = timeInput.bounceBetween(0.3f, 0.7f, periodMs = 4000)\n            val swirlCenterY = timeInput.bounceBetween(0.3f, 0.7f, periodMs = 6000)\n            val swirlAngle = timeInput.bounceBetween(0f, 2f, periodMs = 2000)\n            \n            pipeline(windowSurface) {\n                serialSteps(bitmap.asTexture(), windowSurface) {\n                    // Color adjustments\n                    step(SaturationKraftShader()) { shader ->\n                        shader.saturation = saturationInput.get()\n                    }\n                    \n                    step(ContrastKraftShader()) { shader ->\n                        shader.contrast = contrastInput.get()\n                    }\n                    \n                    step(HueKraftShader()) { shader ->\n                        shader.setHueInDegree(hueRotationInput.get())\n                    }\n                    \n                    // Distortion effect\n                    step(SwirlKraftShader()) { shader ->\n                        shader.center = GlVec2(swirlCenterX.get(), swirlCenterY.get())\n                        shader.angle = swirlAngle.get()\n                        shader.radius = 0.5f\n                    }\n                }\n            }\n        }\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"working-with-timeinput-in-compose",children:"Working with TimeInput in Compose"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"TimeInput"})," class provides several methods for creating time-based animations that work well with Compose:"]}),"\n",(0,i.jsx)(n.h3,{id:"bouncebetween",children:(0,i.jsx)(n.code,{children:"bounceBetween"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"fun bounceBetween(min: Float, max: Float, periodMs: Long = 2000): SampledInput<Float>\n"})}),"\n",(0,i.jsx)(n.p,{children:"Creates an input that oscillates between the minimum and maximum values over the specified period."}),"\n",(0,i.jsx)(n.h3,{id:"map",children:(0,i.jsx)(n.code,{children:"map"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-kotlin",children:"fun <T> map(mapper: (Long) -> T): SampledInput<T>\n"})}),"\n",(0,i.jsx)(n.p,{children:"Creates a custom input by mapping the elapsed time to a value of type T."}),"\n",(0,i.jsx)(n.h2,{id:"lifecycle-management",children:"Lifecycle Management"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"KraftShadeAnimatedView"})," automatically handles the animation lifecycle in sync with Compose's lifecycle:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["When the Composable enters the composition, a new ",(0,i.jsx)(n.code,{children:"AnimatedKraftTextureView"})," is created"]}),"\n",(0,i.jsxs)(n.li,{children:["The view is attached to the provided ",(0,i.jsx)(n.code,{children:"KraftShadeAnimatedState"})]}),"\n",(0,i.jsxs)(n.li,{children:["When the Composable leaves the composition, a ",(0,i.jsx)(n.code,{children:"DisposableEffect"})," calls ",(0,i.jsx)(n.code,{children:"terminate()"})," to clean up resources"]}),"\n",(0,i.jsx)(n.li,{children:"The animation automatically stops when the view is detached from the window"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This ensures proper resource management and prevents unnecessary rendering when the view is not visible."}),"\n",(0,i.jsx)(n.h2,{id:"considerations",children:"Considerations"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Animations run at the device's refresh rate (typically 60fps)"}),"\n",(0,i.jsx)(n.li,{children:"For complex effects, monitor performance and consider simplifying shaders if frame drops occur"}),"\n",(0,i.jsxs)(n.li,{children:["Always call ",(0,i.jsx)(n.code,{children:"stop()"})," when the animation is not visible to conserve battery"]}),"\n",(0,i.jsxs)(n.li,{children:["For non-animated effects, use ",(0,i.jsx)(n.a,{href:"/android-kraft-shade/docs/view-components/jetpack-compose/kraft-shade-effect-view",children:"KraftShadeEffectView"})," instead"]}),"\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"playing"})," property can be used to update UI elements based on the animation state"]}),"\n"]})]})}function m(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var a=t(6540);const i={},s=a.createContext(i);function r(e){const n=a.useContext(s);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),a.createElement(s.Provider,{value:n},e.children)}}}]);