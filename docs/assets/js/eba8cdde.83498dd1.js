"use strict";(self.webpackChunkdoc_website=self.webpackChunkdoc_website||[]).push([[9881],{7378:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"core-components/glenv","title":"GlEnv (Graphics Environment)","description":"The GlEnv (Graphics Environment) is a core component of KraftShade that manages the OpenGL ES environment and EGL context. It serves as the foundation for all rendering operations in the library.","source":"@site/docs/core-components/glenv.md","sourceDirName":"core-components","slug":"/core-components/glenv","permalink":"/android-kraft-shade/docs/core-components/glenv","draft":false,"unlisted":false,"editUrl":"https://github.com/cardinalblue/android-kraft-shade/tree/main/doc_website/docs/core-components/glenv.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Core Components","permalink":"/android-kraft-shade/docs/core-components/"},"next":{"title":"KraftShader","permalink":"/android-kraft-shade/docs/core-components/shader-system/kraft-shader"}}');var t=r(4848),s=r(8453);const a={sidebar_position:1},o="GlEnv (Graphics Environment)",l={},c=[{value:"Overview",id:"overview",level:2},{value:"Key Components",id:"key-components",level:2},{value:"EGL Components",id:"egl-components",level:3},{value:"Execution Environment",id:"execution-environment",level:3},{value:"The Importance of the Dispatcher",id:"the-importance-of-the-dispatcher",level:4},{value:"Suspend Functions in KraftShade",id:"suspend-functions-in-kraftshade",level:4},{value:"Creating a GlEnv Instance",id:"creating-a-glenv-instance",level:2},{value:"Executing GL Operations",id:"executing-gl-operations",level:2},{value:"Using execute()",id:"using-execute",level:3},{value:"Using use()",id:"using-use",level:3},{value:"Posting Deferred Tasks",id:"posting-deferred-tasks",level:3},{value:"Working with Surfaces",id:"working-with-surfaces",level:2},{value:"Window Surfaces",id:"window-surfaces",level:3},{value:"Pixel Buffer Surfaces",id:"pixel-buffer-surfaces",level:3},{value:"Making a Surface Current",id:"making-a-surface-current",level:2},{value:"Swapping Buffers",id:"swapping-buffers",level:2},{value:"Terminating the GL Environment",id:"terminating-the-gl-environment",level:2},{value:"Integration with KraftShade DSL",id:"integration-with-kraftshade-dsl",level:2},{value:"Thread Safety Considerations",id:"thread-safety-considerations",level:2},{value:"Thread Management with Coroutines",id:"thread-management-with-coroutines",level:3},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Common Pitfalls",id:"common-pitfalls",level:2},{value:"Related Components",id:"related-components",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"glenv-graphics-environment",children:"GlEnv (Graphics Environment)"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"GlEnv"})," (Graphics Environment) is a core component of KraftShade that manages the OpenGL ES environment and EGL context. It serves as the foundation for all rendering operations in the library."]}),"\n",(0,t.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"GlEnv"})," handles the initialization of EGL, creation of surfaces, and management of the GL context. It provides a structured way to interact with OpenGL ES, ensuring that operations are performed in the correct thread and context."]}),"\n",(0,t.jsx)(n.mermaid,{value:"flowchart TD\n    A[GlEnv] --\x3e|Initializes| B[EGL Display]\n    A --\x3e|Creates| C[EGL Context]\n    A --\x3e|Manages| D[EGL Surfaces]\n    A --\x3e|Executes| E[GL Commands]\n    A --\x3e|Provides| F[DSL Scope]\n    \n    style A fill:#c73,stroke:#333,stroke-width:2px,font-size:24px,font-weight:bold,white-space: nowrap"}),"\n",(0,t.jsx)(n.h2,{id:"key-components",children:"Key Components"}),"\n",(0,t.jsx)(n.h3,{id:"egl-components",children:"EGL Components"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"EGL Display"}),": The connection to the native display system"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"EGL Config"}),": The chosen configuration that matches rendering requirements"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"EGL Context"}),": The OpenGL ES context essential for all rendering operations"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"EGL Surfaces"}),": Rendering targets (window surfaces, pixel buffers)"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"execution-environment",children:"Execution Environment"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Coroutine Dispatcher"}),": Ensures GL operations run on the correct thread"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"DSL Scope"}),": Provides a domain-specific language for easier interaction with GL operations"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"the-importance-of-the-dispatcher",children:"The Importance of the Dispatcher"}),"\n",(0,t.jsx)(n.p,{children:"In OpenGL, a context is bound to a specific thread. This means that all OpenGL operations for a particular context must be performed on the same thread where the context was created. To handle this constraint, KraftShade creates a dedicated coroutine dispatcher that uses a single thread:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"private val dispatcher = if (useUnconfinedDispatcher) Dispatchers.Unconfined else\n    Executors.newSingleThreadExecutor().asCoroutineDispatcher()\n"})}),"\n",(0,t.jsx)(n.p,{children:"This approach ensures that:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"All GL operations are executed on the correct thread"}),"\n",(0,t.jsx)(n.li,{children:"Developers don't need to worry about thread management when using KraftShade"}),"\n",(0,t.jsx)(n.li,{children:"The OpenGL context remains valid throughout the application lifecycle"}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"suspend-functions-in-kraftshade",children:"Suspend Functions in KraftShade"}),"\n",(0,t.jsx)(n.p,{children:"Most methods in the KraftShade library are defined as suspend functions. This design choice is directly related to the thread constraints of OpenGL:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"suspend fun <T> execute(block: suspend GlEnvDslScope.() -> T): T = withContext(dispatcher) {\n    makeCurrent()\n    executeDeferredTasks()\n    block(dslScope)\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"By using suspend functions and coroutines:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"KraftShade can automatically switch to the correct thread for GL operations"}),"\n",(0,t.jsx)(n.li,{children:"Developers can write sequential code that appears to run on a single thread"}),"\n",(0,t.jsx)(n.li,{children:"The library can manage thread switching transparently"}),"\n",(0,t.jsx)(n.li,{children:"Long-running GL operations don't block the main thread"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This approach simplifies development while ensuring that all OpenGL operations are performed correctly and efficiently."}),"\n",(0,t.jsx)(n.h2,{id:"creating-a-glenv-instance",children:"Creating a GlEnv Instance"}),"\n",(0,t.jsxs)(n.p,{children:["To create a ",(0,t.jsx)(n.code,{children:"GlEnv"})," instance, you need to provide an Android ",(0,t.jsx)(n.code,{children:"Context"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"// Basic initialization\nval glEnv = GlEnv(context)\n\n// With additional options\nval glEnv = GlEnv(\n    context = context,\n    useUnconfinedDispatcher = false,  // Use dedicated thread (recommended for most cases)\n    enableEglAndroidRecordable = false,  // Enable for video recording\n    sharedContext = null  // Optional shared context for resource sharing\n)\n"})}),"\n",(0,t.jsx)(n.h2,{id:"executing-gl-operations",children:"Executing GL Operations"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"GlEnv"})," class provides several methods to execute OpenGL operations:"]}),"\n",(0,t.jsx)(n.h3,{id:"using-execute",children:"Using execute()"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"execute()"})," method ensures that GL operations are performed on the correct thread with the GL context made current:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"glEnv.execute {\n    // OpenGL operations here\n    GLES30.glClearColor(0.0f, 0.0f, 0.0f, 1.0f)\n    GLES30.glClear(GLES30.GL_COLOR_BUFFER_BIT)\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"using-use",children:"Using use()"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"use()"})," method is similar to ",(0,t.jsx)(n.code,{children:"execute()"})," but automatically terminates the GL environment when done:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"glEnv.use {\n    // OpenGL operations here\n    // GL environment will be terminated after this block\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"posting-deferred-tasks",children:"Posting Deferred Tasks"}),"\n",(0,t.jsxs)(n.p,{children:["You can post tasks to be executed during the next ",(0,t.jsx)(n.code,{children:"execute()"})," call:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"glEnv.post {\n    // This will be executed before the next execute() block\n    GLES30.glEnable(GLES30.GL_BLEND)\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"working-with-surfaces",children:"Working with Surfaces"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"GlEnv"})," provides methods to create different types of surfaces:"]}),"\n",(0,t.jsx)(n.h3,{id:"window-surfaces",children:"Window Surfaces"}),"\n",(0,t.jsx)(n.p,{children:"Window surfaces are used for on-screen rendering:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"// From SurfaceTexture\nval surfaceTexture: SurfaceTexture = ...\nval windowSurface = glEnv.createWindowSurface(surfaceTexture)\n\n// From Surface\nval surface: Surface = ...\nval windowSurface = glEnv.createWindowSurface(surface)\n"})}),"\n",(0,t.jsx)(n.h3,{id:"pixel-buffer-surfaces",children:"Pixel Buffer Surfaces"}),"\n",(0,t.jsx)(n.p,{children:"Pixel buffer surfaces are used for off-screen rendering:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"// Create a pbuffer surface\nval size = GlSize(width = 1024, height = 768)\nval pbufferSurface = glEnv.createPbufferSurface(size)\n\n// Create a pixel buffer\nval pixelBuffer = glEnv.createPixelBuffer(width = 1024, height = 768)\n"})}),"\n",(0,t.jsx)(n.h2,{id:"making-a-surface-current",children:"Making a Surface Current"}),"\n",(0,t.jsx)(n.p,{children:"Before performing GL operations on a surface, you need to make it current:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"glEnv.makeCurrent(surface)\n"})}),"\n",(0,t.jsx)(n.h2,{id:"swapping-buffers",children:"Swapping Buffers"}),"\n",(0,t.jsx)(n.p,{children:"After rendering to a window surface, you need to swap buffers to display the result:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"glEnv.swapBuffers(windowSurface)\n"})}),"\n",(0,t.jsx)(n.h2,{id:"terminating-the-gl-environment",children:"Terminating the GL Environment"}),"\n",(0,t.jsx)(n.p,{children:"When you're done with the GL environment, you should terminate it to release resources:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"glEnv.terminate()\n"})}),"\n",(0,t.jsx)(n.h2,{id:"integration-with-kraftshade-dsl",children:"Integration with KraftShade DSL"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"GlEnv"})," integrates with KraftShade's DSL through the ",(0,t.jsx)(n.code,{children:"GlEnvDslScope"})," class, which provides a more convenient way to work with GL operations:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"glEnv.execute {\n    // 'this' is a GlEnvDslScope\n    \n    // Create a pipeline\n    val pipeline = pipeline(targetBuffer) {\n        // Pipeline setup\n    }\n    \n    // Load a texture from assets\n    val texture = loadAssetTexture(\"textures/sample.jpg\")\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"thread-safety-considerations",children:"Thread Safety Considerations"}),"\n",(0,t.jsxs)(n.p,{children:["OpenGL ES operations must be performed on the thread where the GL context was created. ",(0,t.jsx)(n.code,{children:"GlEnv"})," handles this by using a dedicated dispatcher for GL operations:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"By default, a single-threaded executor is used to ensure all GL operations run on the same thread"}),"\n",(0,t.jsxs)(n.li,{children:["You can use ",(0,t.jsx)(n.code,{children:"useUnconfinedDispatcher = true"})," to run on the calling thread, but this should be used with caution"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"thread-management-with-coroutines",children:"Thread Management with Coroutines"}),"\n",(0,t.jsx)(n.p,{children:"The combination of coroutines and a dedicated dispatcher provides several benefits for thread management:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"// This will automatically switch to the GL thread\nglEnv.execute {\n    // All code here runs on the correct GL thread\n    GLES30.glClearColor(0.0f, 0.0f, 0.0f, 1.0f)\n    GLES30.glClear(GLES30.GL_COLOR_BUFFER_BIT)\n}\n\n// This code runs on whatever thread called the function\n// No need to worry about switching back\n"})}),"\n",(0,t.jsx)(n.p,{children:"This approach allows developers to:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Write code that appears sequential and simple"}),"\n",(0,t.jsx)(n.li,{children:"Avoid callback hell or complex thread management"}),"\n",(0,t.jsx)(n.li,{children:"Safely perform GL operations without worrying about thread boundaries"}),"\n",(0,t.jsx)(n.li,{children:"Integrate GL operations with other asynchronous code using coroutines"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"The suspend functions in KraftShade ensure that all GL operations are performed on the correct thread, even when called from different parts of the application or different threads."}),"\n",(0,t.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Context Switching"}),": Minimize the number of ",(0,t.jsx)(n.code,{children:"makeCurrent()"})," calls, as context switching can be expensive"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Surface Creation"}),": Creating surfaces is relatively expensive, so reuse surfaces when possible"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Termination"}),": Always terminate the GL environment when done to prevent resource leaks"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"common-pitfalls",children:"Common Pitfalls"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Using GL Commands Outside Context"}),": Ensure all GL commands are executed within an ",(0,t.jsx)(n.code,{children:"execute()"})," or ",(0,t.jsx)(n.code,{children:"use()"})," block"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Resource Leaks"}),": Failing to terminate the GL environment can lead to resource leaks"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Thread Issues"}),": Attempting to use GL commands from multiple threads can cause crashes or undefined behavior"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"related-components",children:"Related Components"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"GlEnvDslScope"}),": Provides a DSL for working with the GL environment"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Pipeline"}),": Uses GlEnv for executing rendering operations"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"KraftShader"}),": Requires a GlEnv for initialization and execution"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>o});var i=r(6540);const t={},s=i.createContext(t);function a(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);