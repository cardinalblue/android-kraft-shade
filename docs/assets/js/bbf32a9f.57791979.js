"use strict";(self.webpackChunkdoc_website=self.webpackChunkdoc_website||[]).push([[1220],{8453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>a});var r=i(6540);const t={},s=r.createContext(t);function l(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),r.createElement(s.Provider,{value:n},e.children)}},9611:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>l,metadata:()=>r,toc:()=>o});const r=JSON.parse('{"id":"core-components/pipeline-system/pipeline-running-flow","title":"Pipeline Running Flow","description":"This document explains the execution flow of the KraftShade pipeline system, focusing on what happens after the requestRender method is invoked.","source":"@site/docs/core-components/pipeline-system/pipeline-running-flow.md","sourceDirName":"core-components/pipeline-system","slug":"/core-components/pipeline-system/pipeline-running-flow","permalink":"/android-kraft-shade/docs/core-components/pipeline-system/pipeline-running-flow","draft":false,"unlisted":false,"editUrl":"https://github.com/cardinalblue/android-kraft-shade/tree/main/doc_website/docs/core-components/pipeline-system/pipeline-running-flow.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Texture Inputs","permalink":"/android-kraft-shade/docs/core-components/shader-system/texture-inputs"},"next":{"title":"Buffer Management","permalink":"/android-kraft-shade/docs/core-components/pipeline-system/buffer-management"}}');var t=i(4848),s=i(8453);const l={sidebar_position:1},a="Pipeline Running Flow",d={},o=[{value:"Rendering Flow Sequence Diagram",id:"rendering-flow-sequence-diagram",level:2},{value:"Behind the Scenes: What Happens After requestRender",id:"behind-the-scenes-what-happens-after-requestrender",level:2},{value:"1. Request Initiation",id:"1-request-initiation",level:3},{value:"2. Pipeline Execution",id:"2-pipeline-execution",level:3},{value:"Configuration Phase (First Run Only)",id:"configuration-phase-first-run-only",level:4},{value:"Render Phase",id:"render-phase",level:4},{value:"3. Cleanup",id:"3-cleanup",level:3},{value:"Special Considerations",id:"special-considerations",level:3},{value:"Performance Implications",id:"performance-implications",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"pipeline-running-flow",children:"Pipeline Running Flow"})}),"\n",(0,t.jsxs)(n.p,{children:["This document explains the execution flow of the KraftShade pipeline system, focusing on what happens after the ",(0,t.jsx)(n.code,{children:"requestRender"})," method is invoked."]}),"\n",(0,t.jsx)(n.h2,{id:"rendering-flow-sequence-diagram",children:"Rendering Flow Sequence Diagram"}),"\n",(0,t.jsxs)(n.p,{children:["The following sequence diagram illustrates the complete flow from invoking ",(0,t.jsx)(n.code,{children:"requestRender"})," to the final rendering:"]}),"\n",(0,t.jsx)(n.mermaid,{value:'sequenceDiagram\n    participant Client\n    participant KraftEffectTextureView\n    participant Pipeline\n    participant PipelineStep\n    participant KraftShader\n    participant OpenGL\n\n    Client->>KraftEffectTextureView: requestRender()\n    \n    KraftEffectTextureView->>KraftEffectTextureView: renderFlow.emit(Unit)\n    Note over KraftEffectTextureView: Flow collection in onAttachedToWindow\n    KraftEffectTextureView->>KraftEffectTextureView: asyncRender()\n    KraftEffectTextureView->>KraftEffectTextureView: runGlTask()\n    \n    KraftEffectTextureView->>Pipeline: run()\n    \n    alt First run (Configuration Phase)\n        Pipeline->>Pipeline: isRenderPhase = false\n        loop For each step\n            Pipeline->>PipelineStep: run(pipelineRunningScope)\n            PipelineStep->>PipelineStep: setupAction()\n            Note over PipelineStep: Track inputs and buffer references\n        end\n        Pipeline->>Pipeline: isRenderPhase = true\n    end\n    \n    Pipeline->>Pipeline: Mark all sampled inputs as dirty\n    Pipeline->>Pipeline: Sample all inputs\n    Pipeline->>Pipeline: Reset runContext\n    \n    loop For each step\n        Pipeline->>PipelineStep: run(pipelineRunningScope)\n        \n        alt RunShaderStep\n            PipelineStep->>PipelineStep: setupAction(shader)\n            PipelineStep->>PipelineStep: targetBuffer.provideBuffer()\n            PipelineStep->>KraftShader: drawTo(buffer)\n            \n            Note over KraftShader: KraftShader executes its drawing process\n            Note over KraftShader: For details on KraftShader drawing, see docs of [KraftShader]\n            \n            KraftShader->>OpenGL: Render to buffer using OpenGL commands\n            \n            PipelineStep->>Pipeline: markPreviousBuffer(buffer)\n        else RunTaskStep\n            PipelineStep->>PipelineStep: task()\n        end\n        \n        Pipeline->>Pipeline: onDebugAfterShaderStep?.invoke(runContext)\n        \n        alt automaticRecycle is true\n            Pipeline->>Pipeline: recycleUnusedBuffers(step.stepIndex)\n        end\n    end\n    \n    Pipeline->>Pipeline: bufferPool.recycleAll("pipeline_end")'}),"\n",(0,t.jsx)(n.h2,{id:"behind-the-scenes-what-happens-after-requestrender",children:"Behind the Scenes: What Happens After requestRender"}),"\n",(0,t.jsxs)(n.p,{children:["When ",(0,t.jsx)(n.code,{children:"requestRender()"})," is called on a ",(0,t.jsx)(n.code,{children:"KraftEffectTextureView"}),", it triggers a series of operations that ultimately result in rendering the pipeline to the screen. Here's a detailed explanation of what happens behind the scenes:"]}),"\n",(0,t.jsx)(n.h3,{id:"1-request-initiation",children:"1. Request Initiation"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"requestRender()"}),": The process begins when ",(0,t.jsx)(n.code,{children:"requestRender()"})," is called on a ",(0,t.jsx)(n.code,{children:"KraftEffectTextureView"}),". This method emits a value to a ",(0,t.jsx)(n.code,{children:"renderFlow"})," (a Kotlin Flow)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Flow Collection"}),": In ",(0,t.jsx)(n.code,{children:"onAttachedToWindow()"}),", the view sets up a flow collection that samples the ",(0,t.jsx)(n.code,{children:"renderFlow"})," and calls ",(0,t.jsx)(n.code,{children:"asyncRender()"})," when a value is emitted."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"asyncRender()"}),": This method gets the current ",(0,t.jsx)(n.code,{children:"effectExecution"})," (which is a ",(0,t.jsx)(n.code,{children:"Pipeline"})," instance) and runs it using ",(0,t.jsx)(n.code,{children:"runGlTask"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"runGlTask"}),": This method in ",(0,t.jsx)(n.code,{children:"KraftTextureView"})," executes the task on the GL thread, ensuring all OpenGL operations happen on the correct thread."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"2-pipeline-execution",children:"2. Pipeline Execution"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"Pipeline.run()"})," method is the core of the execution process and operates in two distinct phases:"]}),"\n",(0,t.jsx)(n.h4,{id:"configuration-phase-first-run-only",children:"Configuration Phase (First Run Only)"}),"\n",(0,t.jsx)(n.p,{children:"During the first run, the pipeline goes through a configuration phase:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Setup Steps"}),": Each pipeline step is executed with ",(0,t.jsx)(n.code,{children:"isRenderPhase = false"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Track Inputs"}),": The pipeline tracks all sampled inputs that will be needed during rendering."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Buffer Reference Tracking"}),": The pipeline records which step each ",(0,t.jsx)(n.code,{children:"BufferReference"})," is last used in, to enable automatic buffer recycling."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"render-phase",children:"Render Phase"}),"\n",(0,t.jsx)(n.p,{children:"After configuration, the pipeline enters the render phase:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Mark Inputs as Dirty"}),": All sampled inputs are marked as dirty at the start of the frame."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Sample Inputs"}),": All inputs are sampled to get their current values."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Reset Context"}),": The run context is reset for the new frame."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Execute Steps"}),": Each pipeline step is executed in order:"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"For RunShaderStep:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The ",(0,t.jsx)(n.code,{children:"setupAction"})," is called to configure the shader with current input values."]}),"\n",(0,t.jsx)(n.li,{children:"The target buffer is obtained from the buffer provider."}),"\n",(0,t.jsxs)(n.li,{children:["The shader's ",(0,t.jsx)(n.code,{children:"drawTo"})," method is called with the buffer."]}),"\n",(0,t.jsxs)(n.li,{children:["Inside ",(0,t.jsx)(n.code,{children:"drawTo"}),", the shader executes its drawing process. For detailed information about the KraftShader drawing process, see the docs of ",(0,t.jsx)(n.a,{href:"/android-kraft-shade/docs/core-components/shader-system/kraft-shader",children:"KraftShader"}),"."]}),"\n",(0,t.jsx)(n.li,{children:"The buffer is marked as the previous buffer in the run context."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"For RunTaskStep:"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The task is simply executed."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Debug Hook"}),": After each step, the optional ",(0,t.jsx)(n.code,{children:"onDebugAfterShaderStep"})," hook is called."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Buffer Recycling"}),": If automatic recycling is enabled, buffers that won't be used anymore are recycled."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"3-cleanup",children:"3. Cleanup"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Final Recycling"}),": At the end of the pipeline run, all buffers are recycled with ",(0,t.jsx)(n.code,{children:'bufferPool.recycleAll("pipeline_end")'}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"special-considerations",children:"Special Considerations"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Animated Rendering"}),": In ",(0,t.jsx)(n.code,{children:"AnimatedKraftTextureView"}),", rendering is triggered by the Android Choreographer for frame-synchronized animation."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Buffer Management"}),": The pipeline automatically manages texture buffers, recycling them when they're no longer needed to optimize memory usage."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Error Handling"}),": The pipeline includes error handling to catch and report issues during shader compilation and execution."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"performance-implications",children:"Performance Implications"}),"\n",(0,t.jsx)(n.p,{children:"The pipeline running flow is designed for efficiency:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Deferred Parameter Updates"}),": Shader parameter updates are queued and applied in batches during draw calls."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Automatic Buffer Recycling"}),": Texture buffers are automatically recycled when no longer needed."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Input Sampling"}),": Inputs are sampled only once at the beginning of each frame."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Frame Skipping"}),": In animated views, if a frame is still rendering when the next frame is requested, the new frame is skipped to prevent backlog."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"For more information on optimizing pipeline performance, see the Performance Optimization section."})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}}}]);