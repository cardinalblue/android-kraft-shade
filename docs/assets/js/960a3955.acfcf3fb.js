"use strict";(self.webpackChunkdoc_website=self.webpackChunkdoc_website||[]).push([[6557],{65:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>f,contentTitle:()=>a,default:()=>d,frontMatter:()=>l,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"core-components/pipeline-system/buffer-management","title":"Buffer Management","description":"KraftShade\'s pipeline system includes a sophisticated buffer management mechanism that efficiently handles OpenGL texture buffers. This document explains how buffers are managed, tracked, and recycled throughout the pipeline execution process.","source":"@site/docs/core-components/pipeline-system/buffer-management.md","sourceDirName":"core-components/pipeline-system","slug":"/core-components/pipeline-system/buffer-management","permalink":"/android-kraft-shade/docs/core-components/pipeline-system/buffer-management","draft":false,"unlisted":false,"editUrl":"https://github.com/cardinalblue/android-kraft-shade/tree/main/doc_website/docs/core-components/pipeline-system/buffer-management.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Pipeline Running Flow","permalink":"/android-kraft-shade/docs/core-components/pipeline-system/pipeline-running-flow"},"next":{"title":"Input System","permalink":"/android-kraft-shade/docs/core-components/input-system"}}');var s=r(4848),t=r(8453);const l={sidebar_position:2},a="Buffer Management",f={},c=[{value:"Overview",id:"overview",level:2},{value:"TextureBufferPool",id:"texturebufferpool",level:2},{value:"Key Operations",id:"key-operations",level:3},{value:"Implementation Details",id:"implementation-details",level:3},{value:"BufferReference",id:"bufferreference",level:2},{value:"Usage",id:"usage",level:3},{value:"Implementation Details",id:"implementation-details-1",level:3},{value:"Buffer Collection Mechanism",id:"buffer-collection-mechanism",level:2},{value:"How It Works",id:"how-it-works",level:3},{value:"Implementation Details",id:"implementation-details-2",level:3},{value:"Two-Phase Execution and Buffer Management",id:"two-phase-execution-and-buffer-management",level:2},{value:"Configuration Phase",id:"configuration-phase",level:3},{value:"Render Phase",id:"render-phase",level:3},{value:"Performance Benefits",id:"performance-benefits",level:2},{value:"Example: Buffer Lifecycle in a Pipeline",id:"example-buffer-lifecycle-in-a-pipeline",level:2}];function o(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"buffer-management",children:"Buffer Management"})}),"\n",(0,s.jsx)(n.p,{children:"KraftShade's pipeline system includes a sophisticated buffer management mechanism that efficiently handles OpenGL texture buffers. This document explains how buffers are managed, tracked, and recycled throughout the pipeline execution process."}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(n.p,{children:"In graphics processing, texture buffers are used to store intermediate results between shader operations. Creating and destroying these buffers is expensive, so KraftShade implements a buffer pooling system that reuses buffers when possible, significantly improving performance."}),"\n",(0,s.jsx)(n.p,{children:"The buffer management system consists of three main components:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"TextureBufferPool"}),": A pool that manages the lifecycle of texture buffers"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"BufferReference"}),": A handle that references a buffer in the pool"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Buffer Collection Mechanism"}),": A system that tracks buffer usage and recycles buffers when they're no longer needed"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"texturebufferpool",children:"TextureBufferPool"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"TextureBufferPool"})," is responsible for managing a collection of ",(0,s.jsx)(n.code,{children:"TextureBuffer"})," objects. It provides the following functionality:"]}),"\n",(0,s.jsx)(n.mermaid,{value:"classDiagram\n    class TextureBufferPool {\n        +bufferSize: GlSize\n        -map: Map~BufferReference, TextureBuffer~\n        -availableBuffers: List~TextureBuffer~\n        +get(bufferReference): TextureBuffer\n        +recycle(stepNameForDebug, bufferReferences)\n        +recycleAll(stepNameForDebug)\n        +changeSize(size)\n        +delete()\n    }"}),"\n",(0,s.jsx)(n.h3,{id:"key-operations",children:"Key Operations"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Buffer Allocation"}),": When a ",(0,s.jsx)(n.code,{children:"BufferReference"})," requests a buffer, the pool first checks if there's an available buffer that can be reused. If not, it creates a new buffer."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Buffer Recycling"}),": When a buffer is no longer needed, it's moved from the active map to the available buffers list."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Size Management"}),": All buffers in the pool have the same size. When the size changes, all buffers are deleted and will be recreated with the new size when needed."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"implementation-details",children:"Implementation Details"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"operator fun get(bufferReference: BufferReference): TextureBuffer {\n    return map[bufferReference] ?: run {\n        // Try to reuse an available buffer\n        availableBuffers\n            .removeFirstOrNull()\n            ?.let { availableBuffer ->\n                map[bufferReference] = availableBuffer\n                return availableBuffer\n            }\n\n        // Create a new buffer if none are available\n        TextureBuffer(bufferSize).also {\n            map[bufferReference] = it\n        }\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"bufferreference",children:"BufferReference"}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.code,{children:"BufferReference"})," is a handle that represents a buffer in the ",(0,s.jsx)(n.code,{children:"TextureBufferPool"}),". It implements both ",(0,s.jsx)(n.code,{children:"GlBufferProvider"})," and ",(0,s.jsx)(n.code,{children:"TextureProvider"})," interfaces, allowing it to be used in different contexts:"]}),"\n",(0,s.jsx)(n.mermaid,{value:"classDiagram\n    class BufferReference {\n        +nameForDebug: String?\n        +provideBuffer(): GlBuffer\n        +provideTexture(): Texture\n    }\n    BufferReference --|> GlBufferProvider\n    BufferReference --|> TextureProvider"}),"\n",(0,s.jsx)(n.h3,{id:"usage",children:"Usage"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"BufferReference"})," objects are created by the pipeline and used to:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Request Buffers"}),": When a shader needs a target buffer to render to"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Provide Textures"}),": When a shader needs a texture input from a previous step"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Track Buffer Lifecycle"}),": The pipeline system tracks when each reference is last used"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"implementation-details-1",children:"Implementation Details"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"class BufferReference internal constructor(\n    private val pipeline: Pipeline,\n    val nameForDebug: String? = null,\n) : GlBufferProvider, TextureProvider {\n    override fun provideBuffer(): GlBuffer {\n        return pipeline.bufferPool[this]\n    }\n\n    override fun provideTexture(): Texture {\n        return pipeline.getTextureFromBufferPool(this)\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"buffer-collection-mechanism",children:"Buffer Collection Mechanism"}),"\n",(0,s.jsx)(n.p,{children:"The buffer collection mechanism is a key part of KraftShade's performance optimization. It automatically tracks buffer usage and recycles buffers when they're no longer needed."}),"\n",(0,s.jsx)(n.h3,{id:"how-it-works",children:"How It Works"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Usage Tracking"}),": When a ",(0,s.jsx)(n.code,{children:"BufferReference"})," is used as a texture input, the pipeline records the step index in ",(0,s.jsx)(n.code,{children:"bufferReferenceUsage"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Automatic Recycling"}),": After each step, the pipeline checks if any buffers won't be used in future steps and recycles them."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Final Cleanup"}),": At the end of the pipeline run, all buffers are recycled."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"implementation-details-2",children:"Implementation Details"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"// In Pipeline.kt\nprivate fun recycleUnusedBuffers(currentStep: Int) {\n    val buffersToRecycle = bufferReferenceUsage.entries\n        .filter { (_, lastUsedStepIndex) -> lastUsedStepIndex == currentStep }\n        .map { it.key }\n        .toTypedArray()\n\n    if (buffersToRecycle.isNotEmpty()) {\n        bufferPool.recycle(currentStep.toString(), *buffersToRecycle)\n    }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"two-phase-execution-and-buffer-management",children:"Two-Phase Execution and Buffer Management"}),"\n",(0,s.jsx)(n.p,{children:"KraftShade's pipeline execution has two phases that work together with the buffer management system:"}),"\n",(0,s.jsx)(n.h3,{id:"configuration-phase",children:"Configuration Phase"}),"\n",(0,s.jsx)(n.p,{children:"During the first run of a pipeline:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["The pipeline executes each step with ",(0,s.jsx)(n.code,{children:"isRenderPhase = false"})]}),"\n",(0,s.jsxs)(n.li,{children:["As steps request texture inputs, the pipeline tracks which ",(0,s.jsx)(n.code,{children:"BufferReference"})," is used in which step"]}),"\n",(0,s.jsx)(n.li,{children:"This builds a complete map of buffer usage throughout the pipeline"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"render-phase",children:"Render Phase"}),"\n",(0,s.jsx)(n.p,{children:"During subsequent runs:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["The pipeline executes each step with ",(0,s.jsx)(n.code,{children:"isRenderPhase = true"})]}),"\n",(0,s.jsx)(n.li,{children:"After each step, it checks if any buffers won't be used in future steps"}),"\n",(0,s.jsx)(n.li,{children:"Buffers that won't be used again are recycled immediately"}),"\n",(0,s.jsx)(n.li,{children:"At the end of the run, all buffers are recycled"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"performance-benefits",children:"Performance Benefits"}),"\n",(0,s.jsx)(n.p,{children:"This buffer management system provides several performance benefits:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Reduced Memory Usage"}),": By recycling buffers, the system minimizes the number of texture buffers needed."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Minimized GPU Operations"}),": Creating and destroying OpenGL textures is expensive. Reusing buffers reduces these operations."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Automatic Cleanup"}),": Developers don't need to manually manage buffer lifecycles."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Optimized for Complex Pipelines"}),": The system scales well with pipeline complexity, as buffers are recycled as soon as possible."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"example-buffer-lifecycle-in-a-pipeline",children:"Example: Buffer Lifecycle in a Pipeline"}),"\n",(0,s.jsx)(n.p,{children:"Consider a simple pipeline with three steps:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Step 0: Renders to Buffer A"}),"\n",(0,s.jsx)(n.li,{children:"Step 1: Uses Buffer A as input, renders to Buffer B"}),"\n",(0,s.jsx)(n.li,{children:"Step 2: Uses Buffer B as input, renders to the final output"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The buffer lifecycle would be:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Configuration Phase"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Records that Buffer A is last used in Step 1"}),"\n",(0,s.jsx)(n.li,{children:"Records that Buffer B is last used in Step 2"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Render Phase"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"After Step 1: Recycles Buffer A since it won't be used again"}),"\n",(0,s.jsx)(n.li,{children:"After Step 2: Recycles Buffer B"}),"\n",(0,s.jsx)(n.li,{children:"End of pipeline: All buffers are recycled"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"This ensures that at any point, only the necessary buffers are allocated, minimizing memory usage and maximizing performance."})]})}function d(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>l,x:()=>a});var i=r(6540);const s={},t=i.createContext(s);function l(e){const n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);