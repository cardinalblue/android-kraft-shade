"use strict";(self.webpackChunkdoc_website=self.webpackChunkdoc_website||[]).push([[1604],{4020:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>d,contentTitle:()=>a,default:()=>u,frontMatter:()=>l,metadata:()=>r,toc:()=>o});const r=JSON.parse('{"id":"pipeline-dsl/pipeline-modifier","title":"PipelineModifier","description":"PipelineModifier is a powerful feature in KraftShade that allows you to create reusable, composable pipeline components. These modifiers encapsulate complex pipeline operations into reusable units that can be easily integrated into larger pipeline setups.","source":"@site/docs/pipeline-dsl/pipeline-modifier.md","sourceDirName":"pipeline-dsl","slug":"/pipeline-dsl/pipeline-modifier","permalink":"/android-kraft-shade/docs/pipeline-dsl/pipeline-modifier","draft":false,"unlisted":false,"editUrl":"https://github.com/cardinalblue/android-kraft-shade/tree/main/doc_website/docs/pipeline-dsl/pipeline-modifier.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"Nested Pipeline","permalink":"/android-kraft-shade/docs/pipeline-dsl/nested-pipeline"},"next":{"title":"Best Practices","permalink":"/android-kraft-shade/docs/pipeline-dsl/best-practices"}}');var t=n(4848),s=n(8453);const l={sidebar_position:5},a="PipelineModifier",d={},o=[{value:"Overview",id:"overview",level:2},{value:"Creating a PipelineModifier",id:"creating-a-pipelinemodifier",level:2},{value:"Example: Circular Blur with Edge Preservation",id:"example-circular-blur-with-edge-preservation",level:3},{value:"Using PipelineModifier in Pipelines",id:"using-pipelinemodifier-in-pipelines",level:2},{value:"In Serial Pipelines",id:"in-serial-pipelines",level:3},{value:"In Graph Pipelines",id:"in-graph-pipelines",level:3},{value:"Benefits of PipelineModifier",id:"benefits-of-pipelinemodifier",level:2},{value:"1. <strong>Code Reusability</strong>",id:"1-code-reusability",level:3},{value:"2. <strong>Encapsulation</strong>",id:"2-encapsulation",level:3},{value:"3. <strong>Testing</strong>",id:"3-testing",level:3},{value:"4. <strong>Composition</strong>",id:"4-composition",level:3},{value:"5. <strong>Maintainability</strong>",id:"5-maintainability",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. <strong>Single Responsibility</strong>",id:"1-single-responsibility",level:3},{value:"2. <strong>Clear Naming</strong>",id:"2-clear-naming",level:3},{value:"3. <strong>Input Validation</strong>",id:"3-input-validation",level:3},{value:"4. <strong>Documentation</strong>",id:"4-documentation",level:3},{value:"5. <strong>Testing</strong>",id:"5-testing",level:3},{value:"Common Patterns",id:"common-patterns",level:2},{value:"Input Texture Modifier",id:"input-texture-modifier",level:3},{value:"Multi-Input Modifier",id:"multi-input-modifier",level:3},{value:"Integration with Existing Code",id:"integration-with-existing-code",level:2},{value:"Next Steps",id:"next-steps",level:2}];function p(e){const i={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.header,{children:(0,t.jsx)(i.h1,{id:"pipelinemodifier",children:"PipelineModifier"})}),"\n",(0,t.jsx)(i.p,{children:"PipelineModifier is a powerful feature in KraftShade that allows you to create reusable, composable pipeline components. These modifiers encapsulate complex pipeline operations into reusable units that can be easily integrated into larger pipeline setups."}),"\n",(0,t.jsx)(i.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsx)(i.p,{children:"A PipelineModifier is essentially a pre-configured set of pipeline steps that can be applied within any pipeline setup scope. This promotes code reuse, maintainability, and allows you to build complex effects by composing simpler, well-tested components."}),"\n",(0,t.jsx)(i.h2,{id:"creating-a-pipelinemodifier",children:"Creating a PipelineModifier"}),"\n",(0,t.jsx)(i.p,{children:"To create a PipelineModifier, you need to extend one of the base modifier classes:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"PipelineModifierWithInputTexture"})," - For modifiers that process a single input texture"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"PipelineModifierWithBuffers"})," - For modifiers that work with multiple buffer inputs/outputs"]}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"example-circular-blur-with-edge-preservation",children:"Example: Circular Blur with Edge Preservation"}),"\n",(0,t.jsx)(i.p,{children:"Here's a complete example of creating a PipelineModifier that applies circular blur while preserving edges:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-kotlin",children:'package com.cardinalblue.effects.effect.pipeline\n\nimport com.cardinalblue.effects.effect.blur.PreserveEdgeFilter\nimport com.cardinalblue.kraftshade.dsl.GraphPipelineSetupScope\nimport com.cardinalblue.kraftshade.pipeline.PipelineModifierWithInputTexture\nimport com.cardinalblue.kraftshade.pipeline.input.Input\nimport com.cardinalblue.kraftshade.shader.buffer.GlBufferProvider\nimport com.cardinalblue.kraftshade.shader.buffer.TextureProvider\nimport com.cardinalblue.kraftshade.shader.builtin.CircularBlurKraftShader\n\nclass CircularBlurPreservingEdgePipelineModifier(\n    private val amount: Input<Float>,\n    private val repeat: Input<Float>,\n    private val edgeStrength: Input<Float>,\n) : PipelineModifierWithInputTexture() {\n    \n    override suspend fun GraphPipelineSetupScope.addStep(\n        inputTexture: TextureProvider,\n        outputBuffer: GlBufferProvider\n    ) {\n        // Create intermediate buffer references\n        val (edgeTexture, blurredTexture) = createBufferReferences("edge", "blurred")\n\n        // Step 1: Detect edges using Sobel operator\n        with(SobelEdgeDetectionModifier(edgeStrength)) {\n            addStep(inputTexture, edgeTexture)\n        }\n\n        // Step 2: Apply circular blur\n        step(\n            shader = CircularBlurKraftShader(),\n            targetBuffer = blurredTexture,\n        ) { shader ->\n            shader.setInputTexture(inputTexture)\n            shader.amount = amount.get()\n            shader.repeat = repeat.get()\n        }\n\n        // Step 3: Combine original, blurred, and edge textures\n        step(\n            shader = PreserveEdgeFilter(),\n            targetBuffer = outputBuffer,\n        ) { shader ->\n            shader.setInputTexture(inputTexture)\n            shader.setBlurredTexture(blurredTexture)\n            shader.setEdgeTexture(edgeTexture)\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(i.h2,{id:"using-pipelinemodifier-in-pipelines",children:"Using PipelineModifier in Pipelines"}),"\n",(0,t.jsxs)(i.p,{children:["Once you've created a PipelineModifier, you can use it within any pipeline setup scope using the ",(0,t.jsx)(i.code,{children:"with"})," scope function:"]}),"\n",(0,t.jsx)(i.h3,{id:"in-serial-pipelines",children:"In Serial Pipelines"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-kotlin",children:"serialSteps(inputTexture, outputBuffer) {\n    val blurModifier = CircularBlurPreservingEdgePipelineModifier(\n        amount = blurAmount,\n        repeat = constInput(60f),\n        edgeStrength = edgeStrength\n    )\n    \n    with(blurModifier) { addStep() }\n    \n    step(BrightnessKraftShader()) { shader ->\n        shader.brightness = brightness.get()\n    }\n    \n    // Add more steps as needed\n}\n"})}),"\n",(0,t.jsx)(i.h3,{id:"in-graph-pipelines",children:"In Graph Pipelines"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-kotlin",children:'graphPipeline(inputTexture, outputBuffer) {\n    val edgeDetection = SobelEdgeDetectionModifier(constInput(1.0f))\n    val blurEffect = CircularBlurPreservingEdgePipelineModifier(\n        amount = blurAmount,\n        repeat = constInput(30f),\n        edgeStrength = constInput(0.5f)\n    )\n    \n    // Use modifiers within graph nodes\n    node("preprocess") {\n        with(edgeDetection) { addStep() }\n    }\n    \n    node("blur") {\n        with(blurEffect) { addStep() }\n    }\n    \n    // Connect nodes...\n}\n'})}),"\n",(0,t.jsx)(i.h2,{id:"benefits-of-pipelinemodifier",children:"Benefits of PipelineModifier"}),"\n",(0,t.jsxs)(i.h3,{id:"1-code-reusability",children:["1. ",(0,t.jsx)(i.strong,{children:"Code Reusability"})]}),"\n",(0,t.jsx)(i.p,{children:"Create once, use everywhere. PipelineModifiers can be shared across different effects and projects."}),"\n",(0,t.jsxs)(i.h3,{id:"2-encapsulation",children:["2. ",(0,t.jsx)(i.strong,{children:"Encapsulation"})]}),"\n",(0,t.jsx)(i.p,{children:"Hide complex implementation details behind a simple interface. Users only need to know the inputs and outputs."}),"\n",(0,t.jsxs)(i.h3,{id:"3-testing",children:["3. ",(0,t.jsx)(i.strong,{children:"Testing"})]}),"\n",(0,t.jsx)(i.p,{children:"Modifiers can be tested independently, ensuring each component works correctly before integration."}),"\n",(0,t.jsxs)(i.h3,{id:"4-composition",children:["4. ",(0,t.jsx)(i.strong,{children:"Composition"})]}),"\n",(0,t.jsx)(i.p,{children:"Build complex effects by combining simple, well-tested modifiers."}),"\n",(0,t.jsxs)(i.h3,{id:"5-maintainability",children:["5. ",(0,t.jsx)(i.strong,{children:"Maintainability"})]}),"\n",(0,t.jsx)(i.p,{children:"Changes to a modifier's implementation automatically propagate to all uses without code duplication."}),"\n",(0,t.jsx)(i.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsxs)(i.h3,{id:"1-single-responsibility",children:["1. ",(0,t.jsx)(i.strong,{children:"Single Responsibility"})]}),"\n",(0,t.jsx)(i.p,{children:"Each modifier should have a single, well-defined purpose. Avoid creating monolithic modifiers that do too much."}),"\n",(0,t.jsxs)(i.h3,{id:"2-clear-naming",children:["2. ",(0,t.jsx)(i.strong,{children:"Clear Naming"})]}),"\n",(0,t.jsx)(i.p,{children:"Use descriptive names that clearly indicate what the modifier does."}),"\n",(0,t.jsxs)(i.h3,{id:"3-input-validation",children:["3. ",(0,t.jsx)(i.strong,{children:"Input Validation"})]}),"\n",(0,t.jsx)(i.p,{children:"Validate inputs within the modifier to ensure robust error handling."}),"\n",(0,t.jsxs)(i.h3,{id:"4-documentation",children:["4. ",(0,t.jsx)(i.strong,{children:"Documentation"})]}),"\n",(0,t.jsx)(i.p,{children:"Document the modifier's purpose, inputs, outputs, and any special considerations."}),"\n",(0,t.jsxs)(i.h3,{id:"5-testing",children:["5. ",(0,t.jsx)(i.strong,{children:"Testing"})]}),"\n",(0,t.jsx)(i.p,{children:"Create unit tests for your modifiers to ensure they behave correctly in isolation."}),"\n",(0,t.jsx)(i.h2,{id:"common-patterns",children:"Common Patterns"}),"\n",(0,t.jsx)(i.h3,{id:"input-texture-modifier",children:"Input Texture Modifier"}),"\n",(0,t.jsx)(i.p,{children:"For modifiers that process a single texture:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-kotlin",children:"class SimpleBlurModifier(private val radius: Input<Float>) : PipelineModifierWithInputTexture() {\n    override suspend fun GraphPipelineSetupScope.addStep(\n        inputTexture: TextureProvider,\n        outputBuffer: GlBufferProvider\n    ) {\n        step(BlurKraftShader()) { shader ->\n            shader.inputTexture = inputTexture\n            shader.radius = radius.get()\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(i.h3,{id:"multi-input-modifier",children:"Multi-Input Modifier"}),"\n",(0,t.jsx)(i.p,{children:"For modifiers that work with multiple inputs:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-kotlin",children:'class BlendModifier(\n    private val blendMode: Input<BlendMode>,\n    private val opacity: Input<Float>\n) : PipelineModifierWithBuffers() {\n    override suspend fun GraphPipelineSetupScope.addStep(\n        inputs: List<TextureProvider>,\n        outputBuffer: GlBufferProvider\n    ) {\n        require(inputs.size == 2) { "Blend modifier requires exactly 2 inputs" }\n        \n        step(BlendKraftShader()) { shader ->\n            shader.baseTexture = inputs[0]\n            shader.overlayTexture = inputs[1]\n            shader.blendMode = blendMode.get()\n            shader.opacity = opacity.get()\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(i.h2,{id:"integration-with-existing-code",children:"Integration with Existing Code"}),"\n",(0,t.jsx)(i.p,{children:"PipelineModifiers integrate seamlessly with existing KraftShade code:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"They work with both serial and graph pipelines"}),"\n",(0,t.jsx)(i.li,{children:"They support all input types (constants, sliders, external inputs)"}),"\n",(0,t.jsx)(i.li,{children:"They can be nested within other modifiers"}),"\n",(0,t.jsx)(i.li,{children:"They maintain the same performance characteristics as inline pipeline steps"}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["Explore the ",(0,t.jsx)(i.a,{href:"/android-kraft-shade/docs/pipeline-dsl/serial-pipeline",children:"Serial Pipeline"})," documentation for more examples"]}),"\n",(0,t.jsxs)(i.li,{children:["Learn about ",(0,t.jsx)(i.a,{href:"/android-kraft-shade/docs/pipeline-dsl/graph-pipeline",children:"Graph Pipeline"})," for complex multi-pass effects"]}),"\n",(0,t.jsxs)(i.li,{children:["Check out ",(0,t.jsx)(i.a,{href:"/android-kraft-shade/docs/pipeline-dsl/best-practices",children:"Best Practices"})," for advanced usage patterns"]}),"\n"]})]})}function u(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(p,{...e})}):p(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>l,x:()=>a});var r=n(6540);const t={},s=r.createContext(t);function l(e){const i=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function a(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),r.createElement(s.Provider,{value:i},e.children)}}}]);