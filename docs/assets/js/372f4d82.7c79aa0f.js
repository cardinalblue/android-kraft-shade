"use strict";(self.webpackChunkdoc_website=self.webpackChunkdoc_website||[]).push([[2043],{8453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>l});var i=r(6540);const t={},s=i.createContext(t);function a(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),i.createElement(s.Provider,{value:n},e.children)}},9461:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>u,frontMatter:()=>a,metadata:()=>i,toc:()=>p});const i=JSON.parse('{"id":"pipeline-dsl/best-practices","title":"Best Practices","description":"This guide provides recommendations and best practices for using the KraftShade Pipeline DSL effectively. Following these guidelines will help you create efficient, maintainable, and performant shader pipelines.","source":"@site/docs/pipeline-dsl/best-practices.md","sourceDirName":"pipeline-dsl","slug":"/pipeline-dsl/best-practices","permalink":"/android-kraft-shade/docs/pipeline-dsl/best-practices","draft":false,"unlisted":false,"editUrl":"https://github.com/cardinalblue/android-kraft-shade/tree/main/doc_website/docs/pipeline-dsl/best-practices.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6},"sidebar":"tutorialSidebar","previous":{"title":"PipelineModifier","permalink":"/android-kraft-shade/docs/pipeline-dsl/pipeline-modifier"},"next":{"title":"Built-in Shaders","permalink":"/android-kraft-shade/docs/built-in-shaders/"}}');var t=r(4848),s=r(8453);const a={sidebar_position:6},l="Best Practices",o={},p=[{value:"Pipeline Design",id:"pipeline-design",level:2},{value:"Choose the Right Pipeline Type",id:"choose-the-right-pipeline-type",level:3},{value:"Keep Pipelines Modular",id:"keep-pipelines-modular",level:3},{value:"Use Descriptive Names",id:"use-descriptive-names",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Minimize Render Passes",id:"minimize-render-passes",level:3},{value:"Code Organization",id:"code-organization",level:2},{value:"Group Related Operations",id:"group-related-operations",level:3},{value:"Extract Reusable Components",id:"extract-reusable-components",level:3},{value:"Use Higher-Level Abstractions When Appropriate",id:"use-higher-level-abstractions-when-appropriate",level:3},{value:"Error Handling and Debugging",id:"error-handling-and-debugging",level:2},{value:"Use Proper Scope Methods",id:"use-proper-scope-methods",level:3},{value:"Add Debug Information",id:"add-debug-information",level:3},{value:"Check Buffer Sizes",id:"check-buffer-sizes",level:3},{value:"Resource Management",id:"resource-management",level:2},{value:"Release Resources When Done",id:"release-resources-when-done",level:3},{value:"Reuse Textures When Possible",id:"reuse-textures-when-possible",level:3},{value:"Advanced Techniques",id:"advanced-techniques",level:2},{value:"Combine with Serialized Effects",id:"combine-with-serialized-effects",level:3},{value:"Use Custom Run Steps for Complex Operations",id:"use-custom-run-steps-for-complex-operations",level:3},{value:"Leverage Input Parameters",id:"leverage-input-parameters",level:3},{value:"Common Pitfalls to Avoid",id:"common-pitfalls-to-avoid",level:2},{value:"Avoid Excessive Nesting",id:"avoid-excessive-nesting",level:3},{value:"Don&#39;t Ignore Buffer Lifecycle",id:"dont-ignore-buffer-lifecycle",level:3},{value:"Avoid Unnecessary Buffer Creation",id:"avoid-unnecessary-buffer-creation",level:3},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"best-practices",children:"Best Practices"})}),"\n",(0,t.jsx)(n.p,{children:"This guide provides recommendations and best practices for using the KraftShade Pipeline DSL effectively. Following these guidelines will help you create efficient, maintainable, and performant shader pipelines."}),"\n",(0,t.jsx)(n.h2,{id:"pipeline-design",children:"Pipeline Design"}),"\n",(0,t.jsx)(n.h3,{id:"choose-the-right-pipeline-type",children:"Choose the Right Pipeline Type"}),"\n",(0,t.jsx)(n.p,{children:"Select the appropriate pipeline type based on your needs:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Serial Pipeline"}),": Use for linear sequences of effects where each step builds on the previous one."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Graph Pipeline"}),": Use for complex effects that require multiple passes or non-linear processing."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Nested Pipeline"}),": Use for modular, reusable effect components or to organize complex pipelines."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'// Simple linear processing - use Serial Pipeline\nserialSteps(bitmap.asTexture(), windowSurface) {\n    step(ContrastKraftShader())\n    step(SaturationKraftShader())\n}\n\n// Complex multi-pass effect - use Graph Pipeline\ngraphSteps(targetBuffer = windowSurface) {\n    // Create buffer references\n    val (horizontalBlurBuffer, verticalBlurBuffer) = createBufferReferences(\n        "horizontal-blur",\n        "vertical-blur"\n    )\n    \n    // Multiple passes with explicit buffer management\n    stepWithInputTexture(shader, inputTexture, horizontalBlurBuffer)\n    stepWithInputTexture(shader, horizontalBlurBuffer, verticalBlurBuffer)\n    stepWithInputTexture(shader, verticalBlurBuffer, graphTargetBuffer)\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"keep-pipelines-modular",children:"Keep Pipelines Modular"}),"\n",(0,t.jsx)(n.p,{children:"Break down complex effects into smaller, reusable components:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'// Reusable blur component\nfun GraphPipelineSetupScope.applyTwoPassBlur(\n    inputTexture: TextureProvider,\n    outputBuffer: GlBufferProvider,\n    blurSize: Float\n) {\n    val (horizontalBlurBuffer) = createBufferReferences("horizontal-blur")\n    \n    // Horizontal pass\n    stepWithInputTexture(\n        shader = GaussianBlurKraftShader(),\n        inputTexture = inputTexture,\n        targetBuffer = horizontalBlurBuffer\n    ) { shader ->\n        shader.blurSize = blurSize\n        shader.horizontal = true\n    }\n    \n    // Vertical pass\n    stepWithInputTexture(\n        shader = GaussianBlurKraftShader(),\n        inputTexture = horizontalBlurBuffer,\n        targetBuffer = outputBuffer\n    ) { shader ->\n        shader.blurSize = blurSize\n        shader.horizontal = false\n    }\n}\n\n// Usage\ngraphSteps(targetBuffer = windowSurface) {\n    applyTwoPassBlur(bitmap.asTexture(), graphTargetBuffer, 5f)\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"use-descriptive-names",children:"Use Descriptive Names"}),"\n",(0,t.jsx)(n.p,{children:"Give your buffers and steps descriptive names to improve readability and debugging:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'// Good: Descriptive buffer names\nval (horizontalBlurBuffer, verticalBlurBuffer) = createBufferReferences(\n    "horizontal-blur",\n    "vertical-blur"\n)\n\n// Good: Descriptive step purpose\nstep("Apply vignette effect") { runContext ->\n    // Implementation\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,t.jsx)(n.h3,{id:"minimize-render-passes",children:"Minimize Render Passes"}),"\n",(0,t.jsx)(n.p,{children:"Each step in a pipeline requires a render pass, which has overhead. Minimize the number of passes when possible:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"// Less efficient: Two separate steps\nstep(ContrastKraftShader()) { shader ->\n    shader.contrast = 1.5f\n}\nstep(SaturationKraftShader()) { shader ->\n    shader.saturation = 0.8f\n}\n\n// More efficient: Combined shader if possible\nstep(ContrastAndSaturationKraftShader()) { shader ->\n    shader.contrast = 1.5f\n    shader.saturation = 0.8f\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"code-organization",children:"Code Organization"}),"\n",(0,t.jsx)(n.h3,{id:"group-related-operations",children:"Group Related Operations"}),"\n",(0,t.jsx)(n.p,{children:"Group related operations together using nested pipelines:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"serialSteps(inputTexture, targetBuffer) {\n    // Color adjustments group\n    serialStep {\n        step(ContrastKraftShader())\n        step(SaturationKraftShader())\n        step(BrightnessKraftShader())\n    }\n    \n    // Artistic effects group\n    serialStep {\n        step(VignetteKraftShader())\n        step(CrosshatchKraftShader())\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"extract-reusable-components",children:"Extract Reusable Components"}),"\n",(0,t.jsxs)(n.p,{children:["Extract commonly used effect combinations into extension functions or use ",(0,t.jsx)(n.a,{href:"/android-kraft-shade/docs/pipeline-dsl/pipeline-modifier",children:"PipelineModifier"})," for more complex reusable components:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"// Extension function for a common effect combination\nsuspend fun SerialTextureInputPipelineScope.applyBasicColorAdjustments(\n    contrast: Float = 1.0f,\n    saturation: Float = 1.0f,\n    brightness: Float = 0.0f\n) {\n    step(ContrastKraftShader()) { shader ->\n        shader.contrast = contrast\n    }\n    \n    step(SaturationKraftShader()) { shader ->\n        shader.saturation = saturation\n    }\n    \n    step(BrightnessKraftShader()) { shader ->\n        shader.brightness = brightness\n    }\n}\n\n// Usage\nserialSteps(inputTexture, targetBuffer) {\n    applyBasicColorAdjustments(contrast = 1.2f, saturation = 0.8f)\n    // Other steps...\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"use-higher-level-abstractions-when-appropriate",children:"Use Higher-Level Abstractions When Appropriate"}),"\n",(0,t.jsxs)(n.p,{children:["For simple cases, use higher-level abstractions like ",(0,t.jsx)(n.code,{children:"kraftBitmap"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"// Simple, concise approach for basic effects\nval processedBitmap = kraftBitmap(context, inputBitmap) {\n    serialPipeline {\n        step(ContrastKraftShader(1.5f))\n        step(SaturationKraftShader(0.8f))\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"error-handling-and-debugging",children:"Error Handling and Debugging"}),"\n",(0,t.jsx)(n.h3,{id:"use-proper-scope-methods",children:"Use Proper Scope Methods"}),"\n",(0,t.jsx)(n.p,{children:"Use the appropriate methods for each pipeline scope to avoid errors:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"// In a serial pipeline, use serialStep instead of serialSteps\nserialSteps(inputTexture, targetBuffer) {\n    // Correct: Use serialStep for nested serial pipeline\n    serialStep {\n        // Steps here...\n    }\n    \n    // Correct: Use graphStep for nested graph pipeline\n    graphStep { inputTexture ->\n        // Steps here...\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"add-debug-information",children:"Add Debug Information"}),"\n",(0,t.jsx)(n.p,{children:"Include debug information in your pipeline steps:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'// Add purpose for debug\nstep("Apply vignette effect") { runContext ->\n    // Implementation\n}\n\n// Use descriptive buffer names\nval (blurBuffer) = createBufferReferences("gaussian-blur-result")\n'})}),"\n",(0,t.jsx)(n.h3,{id:"check-buffer-sizes",children:"Check Buffer Sizes"}),"\n",(0,t.jsx)(n.p,{children:"Be aware of buffer sizes, especially when working with different input sources:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'// Add a check or log for buffer sizes\nstep("Check buffer sizes") { runContext ->\n    val bufferSize = getPoolBufferSize()\n    KraftLogger.d("Current buffer size: $bufferSize")\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"resource-management",children:"Resource Management"}),"\n",(0,t.jsx)(n.h3,{id:"release-resources-when-done",children:"Release Resources When Done"}),"\n",(0,t.jsx)(n.p,{children:"Ensure resources are properly released when no longer needed:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"// Use the use() extension function for automatic resource cleanup\nGlEnv(context).use { env ->\n    env.execute {\n        // Pipeline operations...\n    }\n} // GlEnv is automatically released here\n"})}),"\n",(0,t.jsx)(n.h3,{id:"reuse-textures-when-possible",children:"Reuse Textures When Possible"}),"\n",(0,t.jsx)(n.p,{children:"For frequently used textures, consider reusing them:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"// Load texture once\nval commonTexture = LoadedTexture(bitmap)\n\n// Use it multiple times\nstepWithInputTexture(shader1, commonTexture, buffer1)\nstepWithInputTexture(shader2, commonTexture, buffer2)\n"})}),"\n",(0,t.jsx)(n.h2,{id:"advanced-techniques",children:"Advanced Techniques"}),"\n",(0,t.jsx)(n.h3,{id:"combine-with-serialized-effects",children:"Combine with Serialized Effects"}),"\n",(0,t.jsx)(n.p,{children:"You can combine DSL-defined pipelines with serialized effects:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"// Apply a serialized effect within a pipeline\nserialSteps(inputTexture, targetBuffer) {\n    // Regular steps\n    step(ContrastKraftShader())\n    \n    // Apply a serialized effect\n    step(serializedEffect, targetBuffer)\n    \n    // More regular steps\n    step(VignetteKraftShader())\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"use-custom-run-steps-for-complex-operations",children:"Use Custom Run Steps for Complex Operations"}),"\n",(0,t.jsx)(n.p,{children:"For operations that don't fit the shader model, use custom run steps:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'step("Custom OpenGL operations") { runContext ->\n    // Direct OpenGL operations\n    GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, frameBufferId)\n    // More OpenGL code...\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"leverage-input-parameters",children:"Leverage Input Parameters"}),"\n",(0,t.jsxs)(n.p,{children:["Use the ",(0,t.jsx)(n.code,{children:"Input<T>"})," type for dynamic shader parameters:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"// Create an input parameter\nval saturationInput = mutableInput(1.0f)\n\n// Use it in a shader\nstep(SaturationKraftShader()) { shader ->\n    shader.saturation = saturationInput.get()\n}\n\n// Later, update the input value\nsaturationInput.set(0.5f)\n"})}),"\n",(0,t.jsx)(n.h2,{id:"common-pitfalls-to-avoid",children:"Common Pitfalls to Avoid"}),"\n",(0,t.jsx)(n.h3,{id:"avoid-excessive-nesting",children:"Avoid Excessive Nesting"}),"\n",(0,t.jsx)(n.p,{children:"While nesting is powerful, excessive nesting can make your code hard to follow:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"// Avoid: Deep nesting\nserialSteps(inputTexture, targetBuffer) {\n    serialStep {\n        graphStep { inputTexture ->\n            serialSteps(inputTexture, graphTargetBuffer) {\n                // Too deep!\n            }\n        }\n    }\n}\n\n// Better: Flatten when possible\nserialSteps(inputTexture, targetBuffer) {\n    // First group of operations\n    step(ContrastKraftShader())\n    \n    // Complex operation as a single graph step\n    graphStep { inputTexture ->\n        // Graph operations here\n    }\n    \n    // Final operations\n    step(VignetteKraftShader())\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"dont-ignore-buffer-lifecycle",children:"Don't Ignore Buffer Lifecycle"}),"\n",(0,t.jsx)(n.p,{children:"Be careful about buffer references that cross pipeline boundaries:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'// Problematic: Using a buffer reference outside its scope\nval (buffer) = createBufferReferences("temp-buffer")\ngraphSteps(targetBuffer) {\n    stepWithInputTexture(shader, inputTexture, buffer)\n}\n// buffer might be recycled here!\nstepWithInputTexture(shader, buffer, outputBuffer) // Potential issue!\n\n// Better: Keep buffer usage within its scope\ngraphSteps(targetBuffer) {\n    val (buffer) = createBufferReferences("temp-buffer")\n    stepWithInputTexture(shader, inputTexture, buffer)\n    stepWithInputTexture(shader, buffer, graphTargetBuffer)\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"avoid-unnecessary-buffer-creation",children:"Avoid Unnecessary Buffer Creation"}),"\n",(0,t.jsx)(n.p,{children:"Don't create new buffers when you can reuse existing ones:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'// Avoid: Creating new buffers for each effect\nserialSteps(inputTexture, targetBuffer) {\n    for (i in 0 until 10) {\n        val (tempBuffer) = createBufferReferences("effect-$i") // Inefficient!\n        // Use tempBuffer...\n    }\n}\n\n// Better: Reuse buffers\nserialSteps(inputTexture, targetBuffer) {\n    // Serial pipeline automatically uses ping-pong buffers\n    for (i in 0 until 10) {\n        step(EffectKraftShader()) { shader ->\n            shader.intensity = i / 10f\n        }\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,t.jsx)(n.p,{children:"By following these best practices, you can create efficient, maintainable, and performant shader pipelines with the KraftShade Pipeline DSL. Remember that the right approach depends on your specific use case, so adapt these guidelines as needed."}),"\n",(0,t.jsx)(n.p,{children:"For more information, refer to the documentation on:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"/android-kraft-shade/docs/pipeline-dsl/introduction",children:"Introduction to the DSL"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"/android-kraft-shade/docs/pipeline-dsl/serial-pipeline",children:"Serial Pipeline"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"/android-kraft-shade/docs/pipeline-dsl/graph-pipeline",children:"Graph Pipeline"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"/android-kraft-shade/docs/pipeline-dsl/nested-pipeline",children:"Nested Pipeline"})}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);