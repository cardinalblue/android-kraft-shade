"use strict";(self.webpackChunkdoc_website=self.webpackChunkdoc_website||[]).push([[2240],{3140:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>l,contentTitle:()=>o,default:()=>f,frontMatter:()=>s,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"view-components/android-views/kraft-video-effect-texture-view","title":"KraftVideoEffectTextureView","description":"KraftVideoEffectTextureView is a specialized view that extends KraftEffectTextureView to provide seamless video playback with shader effects. It handles video rendering, MediaPlayer management, and automatic texture updates for video frames.","source":"@site/docs/view-components/android-views/kraft-video-effect-texture-view.md","sourceDirName":"view-components/android-views","slug":"/view-components/android-views/kraft-video-effect-texture-view","permalink":"/android-kraft-shade/docs/view-components/android-views/kraft-video-effect-texture-view","draft":false,"unlisted":false,"editUrl":"https://github.com/cardinalblue/android-kraft-shade/tree/main/doc_website/docs/view-components/android-views/kraft-video-effect-texture-view.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"AnimatedKraftTextureView","permalink":"/android-kraft-shade/docs/view-components/android-views/animated-kraft-texture-view"},"next":{"title":"KraftShadeView","permalink":"/android-kraft-shade/docs/view-components/jetpack-compose/kraft-shade-view"}}');var r=n(4848),a=n(8453);const s={sidebar_position:4},o="KraftVideoEffectTextureView",l={},d=[{value:"Overview",id:"overview",level:2},{value:"Key Features",id:"key-features",level:2},{value:"Basic Usage",id:"basic-usage",level:2},{value:"Video-Specific Effect Pipeline",id:"video-specific-effect-pipeline",level:2},{value:"<code>setEffectWithPipeline</code>",id:"seteffectwithpipeline",level:3},{value:"Complex Effect Pipeline Example",id:"complex-effect-pipeline-example",level:3},{value:"Playback Controls",id:"playback-controls",level:2},{value:"Setting Video Source",id:"setting-video-source",level:3},{value:"Playback Control Methods",id:"playback-control-methods",level:3},{value:"Lifecycle Methods",id:"lifecycle-methods",level:3},{value:"Important Considerations",id:"important-considerations",level:2},{value:"Memory Management",id:"memory-management",level:3},{value:"Lifecycle Integration",id:"lifecycle-integration",level:3}];function c(e){const i={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(i.header,{children:(0,r.jsx)(i.h1,{id:"kraftvideoeffecttextureview",children:"KraftVideoEffectTextureView"})}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.code,{children:"KraftVideoEffectTextureView"})," is a specialized view that extends ",(0,r.jsx)(i.code,{children:"KraftEffectTextureView"})," to provide seamless video playback with shader effects. It handles video rendering, MediaPlayer management, and automatic texture updates for video frames."]}),"\n",(0,r.jsx)(i.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsx)(i.p,{children:"This view combines video playback capabilities with KraftShade's shader effect system, making it easy to apply real-time effects to video content. It automatically handles:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Video texture creation and management"}),"\n",(0,r.jsx)(i.li,{children:"MediaPlayer lifecycle"}),"\n",(0,r.jsx)(i.li,{children:"Frame synchronization with Choreographer"}),"\n",(0,r.jsx)(i.li,{children:"Video rotation and coordinate system transformations"}),"\n",(0,r.jsx)(i.li,{children:"Playback controls and state management"}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"key-features",children:"Key Features"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Automatic video texture management"}),": Handles ExternalOESTexture creation and updates"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"MediaPlayer integration"}),": Built-in MediaPlayer with proper lifecycle management"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Frame synchronization"}),": Uses Android's Choreographer for smooth frame updates"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Effect pipeline support"}),": Specialized ",(0,r.jsx)(i.code,{children:"setEffectWithPipeline"})," method for video processing"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Playback controls"}),": Play, pause, resume functionality with state tracking"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Lifecycle awareness"}),": Proper handling of activity pause/resume cycles"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Auto-rotation handling"}),": Automatically applies correct video transformations"]}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,r.jsxs)(i.p,{children:["Here's a simple example of using ",(0,r.jsx)(i.code,{children:"KraftVideoEffectTextureView"})," with brightness effect:"]}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-kotlin",children:'class VideoActivity : AppCompatActivity() {\n    private lateinit var videoView: KraftVideoEffectTextureView\n    \n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        \n        // Create the view\n        videoView = KraftVideoEffectTextureView(this)\n        setContentView(videoView)\n        \n        // Set video source\n        val videoUri = Uri.parse("android.resource://$packageName/${R.raw.sample_video}")\n        videoView.setVideoUri(videoUri, autoPlay = true)\n        \n        // Apply brightness effect\n        videoView.setEffectWithPipeline { inputTexture, targetBuffer ->\n            serialSteps(inputTexture, targetBuffer) {\n                step(BrightnessKraftShader(0.2f))\n            }\n        }\n    }\n    \n    override fun onPause() {\n        super.onPause()\n        videoView.onPause()\n    }\n    \n    override fun onResume() {\n        super.onResume()\n        videoView.onResume()\n    }\n    \n    override fun onDestroy() {\n        videoView.releaseMediaPlayer()\n        super.onDestroy()\n    }\n}\n'})}),"\n",(0,r.jsx)(i.h2,{id:"video-specific-effect-pipeline",children:"Video-Specific Effect Pipeline"}),"\n",(0,r.jsx)(i.h3,{id:"seteffectwithpipeline",children:(0,r.jsx)(i.code,{children:"setEffectWithPipeline"})}),"\n",(0,r.jsxs)(i.p,{children:["The most important method for video effects is ",(0,r.jsx)(i.code,{children:"setEffectWithPipeline"}),", which handles video-specific operations automatically:"]}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-kotlin",children:"fun setEffectWithPipeline(\n    afterSet: suspend GlEnvDslScope.(windowSurface: WindowSurfaceBuffer) -> Unit = { requestRender() },\n    effectExecution: suspend GraphPipelineSetupScope.(inputTexture: TextureProvider, targetBuffer: GlBufferProvider) -> Unit\n)\n"})}),"\n",(0,r.jsx)(i.p,{children:"This method automatically handles:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Video texture updates"}),": Calls ",(0,r.jsx)(i.code,{children:"SurfaceTexture.updateTexImage()"})," for the latest frame"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Video rotation"}),": Applies correct rotation transformation from video metadata"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"Vertical flip"}),": Applies necessary coordinate system transformation for video rendering"]}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"complex-effect-pipeline-example",children:"Complex Effect Pipeline Example"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-kotlin",children:"videoView.setEffectWithPipeline { inputTexture, targetBuffer ->\n    serialSteps(inputTexture, targetBuffer) {\n        // Apply saturation effect\n        step(SaturationKraftShader(1.5f))\n        \n        // Apply brightness effect\n        step(BrightnessKraftShader(0.3f))\n        \n        // Apply custom shader\n        step(MyCustomVideoShader()) { shader ->\n            shader.setCustomParameter(someValue)\n        }\n    }\n}\n"})}),"\n",(0,r.jsx)(i.h2,{id:"playback-controls",children:"Playback Controls"}),"\n",(0,r.jsx)(i.h3,{id:"setting-video-source",children:"Setting Video Source"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-kotlin",children:"// Set video with auto-play\nvideoView.setVideoUri(uri, autoPlay = true)\n\n// Set video without auto-play (shows first frame)\nvideoView.setVideoUri(uri, autoPlay = false)\n"})}),"\n",(0,r.jsx)(i.h3,{id:"playback-control-methods",children:"Playback Control Methods"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-kotlin",children:"// Check if video is currently playing\nval isPlaying = videoView.isPlaying()\n\n// Pause playback\nvideoView.pausePlayback()\n\n// Resume playback\nvideoView.resumePlayback()\n\n// Clean up MediaPlayer resources\nvideoView.releaseMediaPlayer()\n"})}),"\n",(0,r.jsx)(i.h3,{id:"lifecycle-methods",children:"Lifecycle Methods"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-kotlin",children:"// In your Activity/Fragment\noverride fun onPause() {\n    super.onPause()\n    videoView.onPause() // Automatically pauses if playing\n}\n\noverride fun onResume() {\n    super.onResume()\n    videoView.onResume() // Resumes if was playing before pause\n}\n"})}),"\n",(0,r.jsx)(i.h2,{id:"important-considerations",children:"Important Considerations"}),"\n",(0,r.jsx)(i.h3,{id:"memory-management",children:"Memory Management"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:["Always call ",(0,r.jsx)(i.code,{children:"releaseMediaPlayer()"})," in your activity's ",(0,r.jsx)(i.code,{children:"onDestroy()"})]}),"\n",(0,r.jsx)(i.li,{children:"The view automatically manages video textures and OpenGL resources"}),"\n",(0,r.jsx)(i.li,{children:"MediaPlayer is reused for multiple videos to optimize memory usage"}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"lifecycle-integration",children:"Lifecycle Integration"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:["Use ",(0,r.jsx)(i.code,{children:"onPause()"})," and ",(0,r.jsx)(i.code,{children:"onResume()"})," methods to properly handle activity lifecycle"]}),"\n",(0,r.jsx)(i.li,{children:"The view automatically tracks playback state during pause/resume cycles"}),"\n",(0,r.jsx)(i.li,{children:"Choreographer callbacks are properly managed to prevent memory leaks"}),"\n"]})]})}function f(e={}){const{wrapper:i}={...(0,a.R)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>s,x:()=>o});var t=n(6540);const r={},a=t.createContext(r);function s(e){const i=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),t.createElement(a.Provider,{value:i},e.children)}}}]);