"use strict";(self.webpackChunkdoc_website=self.webpackChunkdoc_website||[]).push([[9906],{7609:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>t,contentTitle:()=>l,default:()=>c,frontMatter:()=>r,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"built-in-shaders/convolution-mask-processing","title":"Convolution & Mask Processing","description":"Convolution and mask processing shaders in KraftShade enable sophisticated image processing operations like sharpening, embossing, and morphological transformations.","source":"@site/docs/built-in-shaders/convolution-mask-processing.md","sourceDirName":"built-in-shaders","slug":"/built-in-shaders/convolution-mask-processing","permalink":"/android-kraft-shade/docs/built-in-shaders/convolution-mask-processing","draft":false,"unlisted":false,"editUrl":"https://github.com/cardinalblue/android-kraft-shade/tree/main/doc_website/docs/built-in-shaders/convolution-mask-processing.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6},"sidebar":"tutorialSidebar","previous":{"title":"Edge Detection","permalink":"/android-kraft-shade/docs/built-in-shaders/edge-detection"},"next":{"title":"Blending Modes","permalink":"/android-kraft-shade/docs/built-in-shaders/blending-modes"}}');var a=i(4848),o=i(8453);const r={sidebar_position:6},l="Convolution & Mask Processing",t={},d=[{value:"Overview",id:"overview",level:2},{value:"Convolution Base Classes",id:"convolution-base-classes",level:2},{value:"Sample3x3KraftShader",id:"sample3x3kraftshader",level:3},{value:"Convolution3x3KraftShader",id:"convolution3x3kraftshader",level:3},{value:"Convolution3x3WithColorOffsetKraftShader",id:"convolution3x3withcoloroffsetkraftshader",level:3},{value:"Image Enhancement Shaders",id:"image-enhancement-shaders",level:2},{value:"SharpenKraftShader",id:"sharpenkraftshader",level:3},{value:"EmbossKraftShader",id:"embosskraftshader",level:3},{value:"Laplacian Filters",id:"laplacian-filters",level:2},{value:"LaplacianKraftShader",id:"laplaciankraftshader",level:3},{value:"LaplacianMagnitudeKraftShader",id:"laplacianmagnitudekraftshader",level:3},{value:"Morphological Operations",id:"morphological-operations",level:2},{value:"DilationKraftShader",id:"dilationkraftshader",level:3},{value:"ErosionKraftShader",id:"erosionkraftshader",level:3},{value:"Common Convolution Matrices",id:"common-convolution-matrices",level:2},{value:"Box Blur",id:"box-blur",level:3},{value:"Gaussian Blur",id:"gaussian-blur",level:3},{value:"Sharpen",id:"sharpen",level:3},{value:"Edge Detection",id:"edge-detection",level:3},{value:"Emboss",id:"emboss",level:3},{value:"Using Convolution Shaders in Pipelines",id:"using-convolution-shaders-in-pipelines",level:2},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Advanced Techniques",id:"advanced-techniques",level:2},{value:"Combining Morphological Operations",id:"combining-morphological-operations",level:3},{value:"Multi-Pass Convolution",id:"multi-pass-convolution",level:3},{value:"Related Topics",id:"related-topics",level:2}];function h(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"convolution--mask-processing",children:"Convolution & Mask Processing"})}),"\n",(0,a.jsx)(n.p,{children:"Convolution and mask processing shaders in KraftShade enable sophisticated image processing operations like sharpening, embossing, and morphological transformations."}),"\n",(0,a.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,a.jsx)(n.p,{children:"Convolution is a fundamental image processing technique that applies a mathematical operation to each pixel based on its surrounding pixels. This technique is the foundation for many effects including blurring, sharpening, edge detection, and embossing."}),"\n",(0,a.jsx)(n.p,{children:"KraftShade provides several convolution-based shaders that operate on a 3x3 grid of pixels surrounding each pixel in the image. These shaders can be used to create a wide range of effects by simply changing the convolution matrix."}),"\n",(0,a.jsx)(n.h2,{id:"convolution-base-classes",children:"Convolution Base Classes"}),"\n",(0,a.jsx)(n.h3,{id:"sample3x3kraftshader",children:"Sample3x3KraftShader"}),"\n",(0,a.jsx)(n.p,{children:"The base class for shaders that sample a 3x3 grid of pixels around each pixel in the input texture. This class handles the sampling logic but doesn't define how the samples are processed."}),"\n",(0,a.jsx)(n.h3,{id:"convolution3x3kraftshader",children:"Convolution3x3KraftShader"}),"\n",(0,a.jsx)(n.p,{children:"A specialized shader that applies a 3x3 convolution matrix to the image. This is the base class for many convolution-based effects."}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"convolution"}),": GlMat3 representing the 3x3 convolution matrix"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"[IMAGE: Convolution3x3KraftShader - Left side shows original image, right side shows image with custom convolution matrix applied]"}),"\n",(0,a.jsx)(n.h3,{id:"convolution3x3withcoloroffsetkraftshader",children:"Convolution3x3WithColorOffsetKraftShader"}),"\n",(0,a.jsx)(n.p,{children:"An extension of the basic convolution shader that adds a color offset to the result, allowing for more sophisticated effects."}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"convolutionMatrix"}),": GlMat3 representing the 3x3 convolution matrix"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"colorOffset"}),": FloatArray (4 elements) representing RGBA color offsets"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"[IMAGE: Convolution3x3WithColorOffsetKraftShader - Left side shows original image, right side shows image with convolution and color offset applied]"}),"\n",(0,a.jsx)(n.h2,{id:"image-enhancement-shaders",children:"Image Enhancement Shaders"}),"\n",(0,a.jsx)(n.h3,{id:"sharpenkraftshader",children:"SharpenKraftShader"}),"\n",(0,a.jsx)(n.p,{children:"Enhances the details in an image by increasing the contrast between adjacent pixels."}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"imageWidthFactor"}),": Float value related to the image width (default: 0f)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"imageHeightFactor"}),": Float value related to the image height (default: 0f)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"sharpness"}),": Float value controlling the strength of the sharpening effect (default: 0f)"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Example Use Cases:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Enhancing details in photographs"}),"\n",(0,a.jsx)(n.li,{children:"Improving text readability"}),"\n",(0,a.jsx)(n.li,{children:"Compensating for slight blur in images"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"[IMAGE: SharpenKraftShader - Left side shows original image, right side shows sharpened image]"}),"\n",(0,a.jsx)(n.h3,{id:"embosskraftshader",children:"EmbossKraftShader"}),"\n",(0,a.jsx)(n.p,{children:"Creates an embossed effect that makes the image appear raised or stamped."}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"intensity"}),": Float value controlling the strength of the emboss effect (default: 1f)"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Example Use Cases:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Creating metallic or stamped effects"}),"\n",(0,a.jsx)(n.li,{children:"Adding texture to flat surfaces"}),"\n",(0,a.jsx)(n.li,{children:"Creating relief-like images"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"[IMAGE: EmbossKraftShader - Left side shows original image, right side shows embossed image]"}),"\n",(0,a.jsx)(n.h2,{id:"laplacian-filters",children:"Laplacian Filters"}),"\n",(0,a.jsx)(n.h3,{id:"laplaciankraftshader",children:"LaplacianKraftShader"}),"\n",(0,a.jsx)(n.p,{children:"Applies a Laplacian filter to detect edges in all directions. This shader extends Convolution3x3WithColorOffsetKraftShader with a specific convolution matrix."}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Example Use Cases:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Edge detection"}),"\n",(0,a.jsx)(n.li,{children:"Feature extraction"}),"\n",(0,a.jsx)(n.li,{children:"Image analysis"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"[IMAGE: LaplacianKraftShader - Left side shows original image, right side shows image with Laplacian filter applied]"}),"\n",(0,a.jsx)(n.h3,{id:"laplacianmagnitudekraftshader",children:"LaplacianMagnitudeKraftShader"}),"\n",(0,a.jsx)(n.p,{children:"Calculates the magnitude of the Laplacian to detect edges regardless of direction."}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Example Use Cases:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"More robust edge detection"}),"\n",(0,a.jsx)(n.li,{children:"Finding boundaries in images"}),"\n",(0,a.jsx)(n.li,{children:"Preprocessing for computer vision algorithms"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"[IMAGE: LaplacianMagnitudeKraftShader - Left side shows original image, right side shows image with Laplacian magnitude filter applied]"}),"\n",(0,a.jsx)(n.h2,{id:"morphological-operations",children:"Morphological Operations"}),"\n",(0,a.jsx)(n.p,{children:"Morphological operations are a set of non-linear operations related to the shape or morphology of features in an image."}),"\n",(0,a.jsx)(n.h3,{id:"dilationkraftshader",children:"DilationKraftShader"}),"\n",(0,a.jsx)(n.p,{children:"Expands bright regions and shrinks dark regions in an image. This is useful for filling in small holes or gaps."}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"radius"}),": Int value controlling the size of the dilation operation (default: 1)"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Example Use Cases:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Filling in small holes or gaps"}),"\n",(0,a.jsx)(n.li,{children:"Expanding features in binary images"}),"\n",(0,a.jsx)(n.li,{children:"Connecting nearby objects"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"[IMAGE: DilationKraftShader - Left side shows original image, right side shows image after dilation]"}),"\n",(0,a.jsx)(n.h3,{id:"erosionkraftshader",children:"ErosionKraftShader"}),"\n",(0,a.jsx)(n.p,{children:"Shrinks bright regions and expands dark regions in an image. This is useful for removing small objects or thin lines."}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Parameters:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"radius"}),": Int value controlling the size of the erosion operation (default: 1)"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.strong,{children:"Example Use Cases:"})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Removing small objects or noise"}),"\n",(0,a.jsx)(n.li,{children:"Shrinking features in binary images"}),"\n",(0,a.jsx)(n.li,{children:"Separating connected objects"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"[IMAGE: ErosionKraftShader - Left side shows original image, right side shows image after erosion]"}),"\n",(0,a.jsx)(n.h2,{id:"common-convolution-matrices",children:"Common Convolution Matrices"}),"\n",(0,a.jsx)(n.p,{children:"Here are some common convolution matrices that you can use with the Convolution3x3KraftShader:"}),"\n",(0,a.jsx)(n.h3,{id:"box-blur",children:"Box Blur"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"1/9, 1/9, 1/9\n1/9, 1/9, 1/9\n1/9, 1/9, 1/9\n"})}),"\n",(0,a.jsx)(n.h3,{id:"gaussian-blur",children:"Gaussian Blur"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"1/16, 2/16, 1/16\n2/16, 4/16, 2/16\n1/16, 2/16, 1/16\n"})}),"\n",(0,a.jsx)(n.h3,{id:"sharpen",children:"Sharpen"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:" 0, -1,  0\n-1,  5, -1\n 0, -1,  0\n"})}),"\n",(0,a.jsx)(n.h3,{id:"edge-detection",children:"Edge Detection"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"-1, -1, -1\n-1,  8, -1\n-1, -1, -1\n"})}),"\n",(0,a.jsx)(n.h3,{id:"emboss",children:"Emboss"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"-2, -1,  0\n-1,  1,  1\n 0,  1,  2\n"})}),"\n",(0,a.jsx)(n.h2,{id:"using-convolution-shaders-in-pipelines",children:"Using Convolution Shaders in Pipelines"}),"\n",(0,a.jsx)(n.p,{children:"Convolution shaders can be combined with other effects to create sophisticated image processing pipelines. They are particularly effective when used in sequence with color adjustments or blending operations."}),"\n",(0,a.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,a.jsx)(n.p,{children:"When working with convolution operations:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Convolution shaders sample multiple pixels for each output pixel, which can be computationally expensive"}),"\n",(0,a.jsx)(n.li,{children:"Larger convolution kernels (beyond 3x3) are significantly more expensive"}),"\n",(0,a.jsx)(n.li,{children:"For large blur operations, consider using a two-pass approach (horizontal then vertical) instead of a single large convolution"}),"\n",(0,a.jsx)(n.li,{children:"Morphological operations like dilation and erosion can be particularly expensive for large radii"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"advanced-techniques",children:"Advanced Techniques"}),"\n",(0,a.jsx)(n.h3,{id:"combining-morphological-operations",children:"Combining Morphological Operations"}),"\n",(0,a.jsx)(n.p,{children:"Dilation and erosion can be combined to create more complex morphological operations:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Opening"})," (erosion followed by dilation): Removes small objects while preserving the shape and size of larger objects"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Closing"})," (dilation followed by erosion): Fills in small holes and gaps while preserving the shape and size of objects"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"multi-pass-convolution",children:"Multi-Pass Convolution"}),"\n",(0,a.jsx)(n.p,{children:"For more sophisticated effects, you can apply multiple convolution passes in sequence to achieve complex transformations that wouldn't be possible with a single pass."}),"\n",(0,a.jsx)(n.h2,{id:"related-topics",children:"Related Topics"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"./edge-detection",children:"Edge Detection"}),": Learn about specialized edge detection algorithms"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"./blur-distortion",children:"Blur & Distortion"}),": Understand blur effects that use convolution"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.a,{href:"../pipeline-dsl",children:"Pipeline DSL"}),": See how to combine shaders into complex effects"]}),"\n"]})]})}function c(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>l});var s=i(6540);const a={},o=s.createContext(a);function r(e){const n=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);