"use strict";(self.webpackChunkdoc_website=self.webpackChunkdoc_website||[]).push([[6101],{6911:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>l,default:()=>c,frontMatter:()=>a,metadata:()=>s,toc:()=>p});const s=JSON.parse('{"id":"pipeline-dsl/serial-pipeline","title":"Serial Pipeline","description":"A Serial Pipeline in KraftShade is a linear sequence of shader operations where the output of each step becomes the input for the next step. This is the most common and straightforward way to chain multiple effects together.","source":"@site/docs/pipeline-dsl/serial-pipeline.md","sourceDirName":"pipeline-dsl","slug":"/pipeline-dsl/serial-pipeline","permalink":"/android-kraft-shade/docs/pipeline-dsl/serial-pipeline","draft":false,"unlisted":false,"editUrl":"https://github.com/cardinalblue/android-kraft-shade/tree/main/doc_website/docs/pipeline-dsl/serial-pipeline.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Introduction to the DSL","permalink":"/android-kraft-shade/docs/pipeline-dsl/introduction"},"next":{"title":"Graph Pipeline","permalink":"/android-kraft-shade/docs/pipeline-dsl/graph-pipeline"}}');var r=i(4848),t=i(8453);const a={sidebar_position:2},l="Serial Pipeline",d={},p=[{value:"Understanding Serial Pipelines",id:"understanding-serial-pipelines",level:2},{value:"Creating a Serial Pipeline",id:"creating-a-serial-pipeline",level:2},{value:"1. Using <code>serialSteps</code>",id:"1-using-serialsteps",level:3},{value:"2. Using <code>kraftBitmap</code> with <code>serialPipeline</code>",id:"2-using-kraftbitmap-with-serialpipeline",level:3},{value:"Adding Steps to a Serial Pipeline",id:"adding-steps-to-a-serial-pipeline",level:2},{value:"Ping-Pong Buffer Mechanism",id:"ping-pong-buffer-mechanism",level:2},{value:"Advanced Serial Pipeline Features",id:"advanced-serial-pipeline-features",level:2},{value:"Mixture Steps",id:"mixture-steps",level:3},{value:"Custom Run Steps",id:"custom-run-steps",level:3},{value:"Real-World Example",id:"real-world-example",level:2},{value:"Performance Considerations",id:"performance-considerations",level:2}];function o(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"serial-pipeline",children:"Serial Pipeline"})}),"\n",(0,r.jsx)(n.p,{children:"A Serial Pipeline in KraftShade is a linear sequence of shader operations where the output of each step becomes the input for the next step. This is the most common and straightforward way to chain multiple effects together."}),"\n",(0,r.jsx)(n.h2,{id:"understanding-serial-pipelines",children:"Understanding Serial Pipelines"}),"\n",(0,r.jsx)(n.p,{children:"Serial pipelines are ideal for:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Applying multiple effects in sequence"}),"\n",(0,r.jsx)(n.li,{children:"Creating a processing chain where each step builds on the previous one"}),"\n",(0,r.jsx)(n.li,{children:"Simple image processing workflows"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"The key characteristic of a serial pipeline is its linear nature - data flows from one step to the next in a predefined order."}),"\n",(0,r.jsx)(n.h2,{id:"creating-a-serial-pipeline",children:"Creating a Serial Pipeline"}),"\n",(0,r.jsx)(n.p,{children:"KraftShade provides two main ways to create serial pipelines:"}),"\n",(0,r.jsxs)(n.h3,{id:"1-using-serialsteps",children:["1. Using ",(0,r.jsx)(n.code,{children:"serialSteps"})]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"serialSteps"})," function is the primary way to create a serial pipeline within a larger pipeline context:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-kotlin",children:"pipeline(windowSurface) {\n    serialSteps(\n        inputTexture = bitmap.asTexture(),\n        targetBuffer = windowSurface\n    ) {\n        // Serial steps defined here\n    }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Parameters:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"inputTexture"}),": The initial texture input for the first step"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"targetBuffer"}),": The final output buffer where the result will be rendered"]}),"\n",(0,r.jsx)(n.li,{children:"A lambda block where you define the steps of the serial pipeline"}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"2-using-kraftbitmap-with-serialpipeline",children:["2. Using ",(0,r.jsx)(n.code,{children:"kraftBitmap"})," with ",(0,r.jsx)(n.code,{children:"serialPipeline"})]}),"\n",(0,r.jsxs)(n.p,{children:["For simpler use cases, especially when working with bitmaps, you can use the higher-level ",(0,r.jsx)(n.code,{children:"kraftBitmap"})," DSL with ",(0,r.jsx)(n.code,{children:"serialPipeline"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-kotlin",children:"val processedBitmap = kraftBitmap(context, inputBitmap) {\n    serialPipeline {\n        step(ContrastKraftShader(4f))\n        step(BrightnessKraftShader(-0.5f))\n    }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"This approach is more concise and focuses on the shaders rather than the pipeline mechanics."}),"\n",(0,r.jsx)(n.h2,{id:"adding-steps-to-a-serial-pipeline",children:"Adding Steps to a Serial Pipeline"}),"\n",(0,r.jsxs)(n.p,{children:["Within a serial pipeline, you can add steps using the ",(0,r.jsx)(n.code,{children:"step"})," function:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-kotlin",children:"serialSteps(bitmap.asTexture(), windowSurface) {\n    step(CrosshatchKraftShader()) { shader ->\n        shader.crossHatchSpacing = 0.03f\n        shader.lineWidth = 0.003f\n    }\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Each ",(0,r.jsx)(n.code,{children:"step"})," takes a shader instance and an optional setup action that configures the shader parameters."]}),"\n",(0,r.jsx)(n.h2,{id:"ping-pong-buffer-mechanism",children:"Ping-Pong Buffer Mechanism"}),"\n",(0,r.jsx)(n.p,{children:"Behind the scenes, serial pipelines use a ping-pong buffer mechanism to efficiently chain operations:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:'The first step renders to "buffer1" (ping)'}),"\n",(0,r.jsx)(n.li,{children:'The second step uses "buffer1" as input and renders to "buffer2" (pong)'}),"\n",(0,r.jsx)(n.li,{children:'The third step uses "buffer2" as input and renders to "buffer1" (ping)'}),"\n",(0,r.jsx)(n.li,{children:"And so on..."}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["This mechanism is handled automatically by the ",(0,r.jsx)(n.code,{children:"SerialTextureInputPipelineScope"})," class, which creates and manages the necessary buffer references."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-kotlin",children:'// From the PipelineDSL.kt implementation\nvar drawToBuffer1 = true\nval (buffer1, buffer2) = BufferReferenceCreator(\n    pipeline,\n    "$bufferReferencePrefix-ping",\n    "$bufferReferencePrefix-pong",\n)\n'})}),"\n",(0,r.jsx)(n.h2,{id:"advanced-serial-pipeline-features",children:"Advanced Serial Pipeline Features"}),"\n",(0,r.jsx)(n.h3,{id:"mixture-steps",children:"Mixture Steps"}),"\n",(0,r.jsxs)(n.p,{children:["You can mix the output of a shader with the original input using ",(0,r.jsx)(n.code,{children:"stepWithMixture"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-kotlin",children:"serialSteps(bitmap.asTexture(), windowSurface) {\n    stepWithMixture(\n        shader = GrayScaleKraftShader(),\n        mixturePercentInput = constInput(0.5f)\n    )\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["This creates a blend between the shader output and the original input, controlled by the ",(0,r.jsx)(n.code,{children:"mixturePercentInput"})," parameter (0.0 to 1.0)."]}),"\n",(0,r.jsx)(n.h3,{id:"custom-run-steps",children:"Custom Run Steps"}),"\n",(0,r.jsx)(n.p,{children:"For more complex operations that don't fit the shader model, you can use a custom run step. It's guaranteed the running thread will be the one that has the GL context. You can change blending setup or do anything with or without using OpenGL API."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-kotlin",children:'serialSteps(bitmap.asTexture(), windowSurface) {\n    step("Custom operation") { runContext ->\n        // Custom OpenGL operations here\n    }\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"real-world-example",children:"Real-World Example"}),"\n",(0,r.jsx)(n.p,{children:"Here's a complete example that applies multiple effects in a serial pipeline:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-kotlin",children:"pipeline(windowSurface) {\n    serialSteps(\n        inputTexture = bitmap.asTexture(),\n        targetBuffer = windowSurface\n    ) {\n        // Apply a contrast adjustment\n        step(ContrastKraftShader()) { shader ->\n            shader.contrast = 1.5f\n        }\n        \n        // Apply a saturation adjustment\n        step(SaturationKraftShader()) { shader ->\n            shader.saturation = 0.8f\n        }\n        \n        // Apply a vignette effect\n        step(VignetteKraftShader()) { shader ->\n            shader.vignetteStart = 0.8f\n            shader.vignetteEnd = 0.3f\n        }\n    }\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"This creates a processing chain that:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Adjusts the contrast of the input image"}),"\n",(0,r.jsx)(n.li,{children:"Reduces the saturation of the contrast-adjusted image"}),"\n",(0,r.jsx)(n.li,{children:"Applies a vignette effect to the contrast-adjusted, desaturated image"}),"\n",(0,r.jsx)(n.li,{children:"Renders the final result to the window surface"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,r.jsx)(n.p,{children:"Serial pipelines are efficient for most use cases, but keep in mind:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Each step requires a render pass, which has some overhead"}),"\n",(0,r.jsx)(n.li,{children:"The ping-pong buffer mechanism requires additional memory"}),"\n",(0,r.jsx)(n.li,{children:"Very long chains of effects may impact performance"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["For complex effects that require multiple passes, consider using a ",(0,r.jsx)(n.a,{href:"/android-kraft-shade/docs/pipeline-dsl/graph-pipeline",children:"Graph Pipeline"})," or ",(0,r.jsx)(n.a,{href:"/android-kraft-shade/docs/pipeline-dsl/nested-pipeline",children:"Nested Pipeline"})," for more flexibility."]})]})}function c(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(o,{...e})}):o(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>l});var s=i(6540);const r={},t=s.createContext(r);function a(e){const n=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);