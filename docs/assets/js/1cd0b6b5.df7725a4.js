"use strict";(self.webpackChunkdoc_website=self.webpackChunkdoc_website||[]).push([[6680],{1262:(e,a,s)=>{s.r(a),s.d(a,{assets:()=>l,contentTitle:()=>d,default:()=>p,frontMatter:()=>i,metadata:()=>r,toc:()=>o});const r=JSON.parse('{"id":"built-in-shaders/base-shaders","title":"Base Shaders","description":"Base shaders provide fundamental operations that serve as building blocks for more complex effects in KraftShade.","source":"@site/docs/built-in-shaders/base-shaders.md","sourceDirName":"built-in-shaders","slug":"/built-in-shaders/base-shaders","permalink":"/android-kraft-shade/docs/built-in-shaders/base-shaders","draft":false,"unlisted":false,"editUrl":"https://github.com/cardinalblue/android-kraft-shade/tree/main/doc_website/docs/built-in-shaders/base-shaders.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Built-in Shaders","permalink":"/android-kraft-shade/docs/built-in-shaders/"},"next":{"title":"Color Effects","permalink":"/android-kraft-shade/docs/built-in-shaders/color-effects"}}');var t=s(4848),n=s(8453);const i={sidebar_position:1},d="Base Shaders",l={},o=[{value:"Overview",id:"overview",level:2},{value:"Available Base Shaders",id:"available-base-shaders",level:2},{value:"DoNothingKraftShader",id:"donothingkraftshader",level:3},{value:"BypassableTextureInputKraftShader",id:"bypassabletextureinputkraftshader",level:3},{value:"BypassableTwoTextureInputKraftShader",id:"bypassabletwotextureinputkraftshader",level:3},{value:"Base Shader Types",id:"base-shader-types",level:2},{value:"TextureInputKraftShader",id:"textureinputkraftshader",level:3},{value:"TwoTextureInputKraftShader",id:"twotextureinputkraftshader",level:3},{value:"Sample3x3KraftShader",id:"sample3x3kraftshader",level:3},{value:"SingleDirectionForTwoPassSamplingKraftShader",id:"singledirectionfortwopasssamplingkraftshader",level:3},{value:"Using Base Shaders in Pipelines",id:"using-base-shaders-in-pipelines",level:2},{value:"Creating Custom Base Shaders",id:"creating-custom-base-shaders",level:2},{value:"Related Topics",id:"related-topics",level:2}];function h(e){const a={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,n.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(a.header,{children:(0,t.jsx)(a.h1,{id:"base-shaders",children:"Base Shaders"})}),"\n",(0,t.jsx)(a.p,{children:"Base shaders provide fundamental operations that serve as building blocks for more complex effects in KraftShade."}),"\n",(0,t.jsx)(a.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsx)(a.p,{children:"Base shaders are the foundation of KraftShade's shader system. They implement essential operations that can be used alone or combined with other shaders to create sophisticated visual effects. These shaders are optimized for performance and follow a consistent API pattern."}),"\n",(0,t.jsx)(a.h2,{id:"available-base-shaders",children:"Available Base Shaders"}),"\n",(0,t.jsx)(a.h3,{id:"donothingkraftshader",children:"DoNothingKraftShader"}),"\n",(0,t.jsx)(a.p,{children:"The simplest shader that passes the input texture to the output without any modifications. This shader is useful as a placeholder or for testing purposes."}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-kotlin",children:"// Create a shader that does nothing to the input\nval shader = DoNothingKraftShader()\n"})}),"\n",(0,t.jsx)(a.h3,{id:"bypassabletextureinputkraftshader",children:"BypassableTextureInputKraftShader"}),"\n",(0,t.jsx)(a.p,{children:"A wrapper shader that can conditionally bypass the wrapped shader's processing. This is useful for enabling/disabling effects dynamically without restructuring your pipeline."}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-kotlin",children:"// Create a saturation shader that can be bypassed\nval saturationShader = SaturationKraftShader(saturation = 1.5f)\nval bypassableShader = BypassableTextureInputKraftShader(\n    wrappedShader = saturationShader,\n    bypass = false // Initially enabled\n)\n\n// Later, to bypass the shader:\nbypassableShader.bypass = true\n"})}),"\n",(0,t.jsx)(a.h3,{id:"bypassabletwotextureinputkraftshader",children:"BypassableTwoTextureInputKraftShader"}),"\n",(0,t.jsxs)(a.p,{children:["Similar to ",(0,t.jsx)(a.code,{children:"BypassableTextureInputKraftShader"}),", but designed for shaders that take two input textures (like blend shaders)."]}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-kotlin",children:"// Create a blend shader that can be bypassed\nval blendShader = MultiplyBlendKraftShader()\nval bypassableShader = BypassableTwoTextureInputKraftShader(\n    wrappedShader = blendShader,\n    bypass = false, // Initially enabled\n    passTexture1 = true // When bypassed, pass the first texture\n)\n"})}),"\n",(0,t.jsx)(a.h2,{id:"base-shader-types",children:"Base Shader Types"}),"\n",(0,t.jsx)(a.p,{children:"KraftShade provides several base shader types that serve as parent classes for more specific shader implementations:"}),"\n",(0,t.jsx)(a.h3,{id:"textureinputkraftshader",children:"TextureInputKraftShader"}),"\n",(0,t.jsx)(a.p,{children:"The most common base shader type that takes a single texture as input and produces a modified output."}),"\n",(0,t.jsx)(a.h3,{id:"twotextureinputkraftshader",children:"TwoTextureInputKraftShader"}),"\n",(0,t.jsx)(a.p,{children:"A base shader type that takes two textures as input, typically used for blending operations."}),"\n",(0,t.jsx)(a.h3,{id:"sample3x3kraftshader",children:"Sample3x3KraftShader"}),"\n",(0,t.jsx)(a.p,{children:"A specialized shader that samples a 3x3 grid of pixels around each pixel in the input texture. This is the foundation for convolution operations, edge detection, and other neighborhood-based effects."}),"\n",(0,t.jsx)(a.h3,{id:"singledirectionfortwopasssamplingkraftshader",children:"SingleDirectionForTwoPassSamplingKraftShader"}),"\n",(0,t.jsx)(a.p,{children:"A specialized shader designed for two-pass operations where each pass processes the image in a different direction (typically horizontal and vertical). This approach is used for separable filters like Gaussian blur for better performance."}),"\n",(0,t.jsx)(a.h2,{id:"using-base-shaders-in-pipelines",children:"Using Base Shaders in Pipelines"}),"\n",(0,t.jsx)(a.p,{children:"Base shaders can be used directly in your rendering pipelines:"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-kotlin",children:"pipeline(targetBuffer) {\n    serialSteps(\n        inputTexture = inputBitmap.asTexture(),\n        targetBuffer = targetBuffer\n    ) {\n        // Use a base shader as a placeholder or for testing\n        step(DoNothingKraftShader())\n        \n        // Use a bypassable shader for conditional processing\n        val bypassableShader = BypassableTextureInputKraftShader(\n            wrappedShader = SaturationKraftShader(saturation = 1.5f)\n        )\n        step(bypassableShader)\n    }\n}\n"})}),"\n",(0,t.jsx)(a.h2,{id:"creating-custom-base-shaders",children:"Creating Custom Base Shaders"}),"\n",(0,t.jsx)(a.p,{children:"You can extend the base shader types to create your own custom shaders. For example:"}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-kotlin",children:'class MyCustomShader : TextureInputKraftShader() {\n    var intensity: Float by GlUniformDelegate("intensity")\n    \n    init {\n        intensity = 1.0f\n    }\n    \n    override fun loadFragmentShader(): String {\n        return """\n            precision mediump float;\n            varying vec2 textureCoordinate;\n            uniform sampler2D inputImageTexture;\n            uniform float intensity;\n            \n            void main() {\n                vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);\n                // Apply your custom effect here\n                gl_FragColor = textureColor * intensity;\n            }\n        """\n    }\n}\n'})}),"\n",(0,t.jsx)(a.h2,{id:"related-topics",children:"Related Topics"}),"\n",(0,t.jsxs)(a.ul,{children:["\n",(0,t.jsxs)(a.li,{children:[(0,t.jsx)(a.a,{href:"../core-components/shader-system/kraft-shader",children:"KraftShader"}),": Learn about the base shader class"]}),"\n",(0,t.jsxs)(a.li,{children:[(0,t.jsx)(a.a,{href:"../core-components/shader-system/gl-uniform-delegate",children:"GlUniformDelegate"}),": Understand how shader parameters are managed"]}),"\n",(0,t.jsxs)(a.li,{children:[(0,t.jsx)(a.a,{href:"../pipeline-dsl",children:"Pipeline DSL"}),": See how to combine shaders into pipelines"]}),"\n"]})]})}function p(e={}){const{wrapper:a}={...(0,n.R)(),...e.components};return a?(0,t.jsx)(a,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},8453:(e,a,s)=>{s.d(a,{R:()=>i,x:()=>d});var r=s(6540);const t={},n=r.createContext(t);function i(e){const a=r.useContext(n);return r.useMemo(function(){return"function"==typeof e?e(a):{...a,...e}},[a,e])}function d(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),r.createElement(n.Provider,{value:a},e.children)}}}]);