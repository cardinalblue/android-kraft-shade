"use strict";(self.webpackChunkdoc_website=self.webpackChunkdoc_website||[]).push([[2664],{5784:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>o,contentTitle:()=>l,default:()=>c,frontMatter:()=>a,metadata:()=>s,toc:()=>p});const s=JSON.parse('{"id":"pipeline-dsl/introduction","title":"Introduction to the DSL","description":"The KraftShade Pipeline DSL (Domain Specific Language) provides a concise and expressive way to define image processing pipelines. It allows you to chain multiple shader effects together in various configurations to create complex visual effects.","source":"@site/docs/pipeline-dsl/introduction.md","sourceDirName":"pipeline-dsl","slug":"/pipeline-dsl/introduction","permalink":"/android-kraft-shade/docs/pipeline-dsl/introduction","draft":false,"unlisted":false,"editUrl":"https://github.com/cardinalblue/android-kraft-shade/tree/main/doc_website/docs/pipeline-dsl/introduction.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Pipeline DSL","permalink":"/android-kraft-shade/docs/pipeline-dsl/"},"next":{"title":"Serial Pipeline","permalink":"/android-kraft-shade/docs/pipeline-dsl/serial-pipeline"}}');var r=n(4848),t=n(8453);const a={sidebar_position:1},l="Introduction to the DSL",o={},p=[{value:"What is a Pipeline DSL?",id:"what-is-a-pipeline-dsl",level:2},{value:"Core Concepts",id:"core-concepts",level:2},{value:"Pipeline",id:"pipeline",level:3},{value:"Steps",id:"steps",level:3},{value:"Textures and Buffers",id:"textures-and-buffers",level:3},{value:"Pipeline Types",id:"pipeline-types",level:2},{value:"Basic Usage",id:"basic-usage",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const i={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(i.header,{children:(0,r.jsx)(i.h1,{id:"introduction-to-the-dsl",children:"Introduction to the DSL"})}),"\n",(0,r.jsx)(i.p,{children:"The KraftShade Pipeline DSL (Domain Specific Language) provides a concise and expressive way to define image processing pipelines. It allows you to chain multiple shader effects together in various configurations to create complex visual effects."}),"\n",(0,r.jsx)(i.h2,{id:"what-is-a-pipeline-dsl",children:"What is a Pipeline DSL?"}),"\n",(0,r.jsx)(i.p,{children:"A Pipeline DSL is a specialized syntax designed to make it easier to create and configure image processing pipelines. In KraftShade, the Pipeline DSL provides a structured way to:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"Define the sequence of shader operations"}),"\n",(0,r.jsx)(i.li,{children:"Configure shader parameters"}),"\n",(0,r.jsx)(i.li,{children:"Manage texture inputs and outputs"}),"\n",(0,r.jsx)(i.li,{children:"Handle buffer allocation and recycling"}),"\n",(0,r.jsx)(i.li,{children:"Create complex multi-pass rendering graphs"}),"\n"]}),"\n",(0,r.jsx)(i.p,{children:"The DSL abstracts away many of the low-level details of OpenGL programming, allowing you to focus on the creative aspects of shader development."}),"\n",(0,r.jsx)(i.h2,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,r.jsx)(i.h3,{id:"pipeline",children:"Pipeline"}),"\n",(0,r.jsx)(i.p,{children:"A pipeline is a sequence of rendering steps that process an input image to produce an output image. Each step in the pipeline typically applies a specific shader effect."}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-kotlin",children:"pipeline(windowSurface) {\n    // Pipeline steps defined here\n}\n"})}),"\n",(0,r.jsx)(i.h3,{id:"steps",children:"Steps"}),"\n",(0,r.jsx)(i.p,{children:"Steps are individual operations within a pipeline. Each step typically applies a shader to an input texture and renders the result to an output buffer."}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-kotlin",children:"step(SaturationKraftShader()) { shader ->\n    shader.saturation = 0.5f\n}\n"})}),"\n",(0,r.jsx)(i.h3,{id:"textures-and-buffers",children:"Textures and Buffers"}),"\n",(0,r.jsx)(i.p,{children:"Textures represent image data in GPU memory, while buffers are targets for rendering operations. The Pipeline DSL manages the allocation and recycling of these resources automatically."}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-kotlin",children:'// Convert a bitmap to a texture\nval inputTexture = bitmap.asTexture()\n\n// Create a buffer reference\nval (buffer1, buffer2) = createBufferReferences("ping", "pong")\n'})}),"\n",(0,r.jsx)(i.h2,{id:"pipeline-types",children:"Pipeline Types"}),"\n",(0,r.jsx)(i.p,{children:"KraftShade supports several pipeline structures:"}),"\n",(0,r.jsxs)(i.ol,{children:["\n",(0,r.jsxs)(i.li,{children:["\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.strong,{children:"Serial Pipeline"}),": A linear sequence of shader operations where each step's output becomes the input for the next step."]}),"\n"]}),"\n",(0,r.jsxs)(i.li,{children:["\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.strong,{children:"Graph Pipeline"}),": A more complex structure where steps can have multiple inputs and outputs, allowing for non-linear processing flows."]}),"\n"]}),"\n",(0,r.jsxs)(i.li,{children:["\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.strong,{children:"Nested Pipeline"}),": A combination of serial and graph pipelines, allowing for modular and reusable pipeline components."]}),"\n"]}),"\n",(0,r.jsxs)(i.li,{children:["\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.strong,{children:"PipelineModifier"}),": Reusable pipeline components that encapsulate complex operations into single, composable units."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,r.jsx)(i.p,{children:"Here's a simple example of using the Pipeline DSL to apply a crosshatch effect to an image:"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-kotlin",children:"pipeline(windowSurface) {\n    serialSteps(bitmap.asTexture(), windowSurface) {\n        step(CrosshatchKraftShader()) { shader ->\n            shader.crossHatchSpacing = 0.03f\n            shader.lineWidth = 0.003f\n        }\n    }\n}\n"})}),"\n",(0,r.jsxs)(i.p,{children:["For more complex image processing, you can use the higher-level ",(0,r.jsx)(i.code,{children:"kraftBitmap"})," DSL:"]}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-kotlin",children:"val processedBitmap = kraftBitmap(context, inputBitmap) {\n    serialPipeline {\n        step(ContrastKraftShader(4f))\n        step(BrightnessKraftShader(-0.5f))\n    }\n}\n"})}),"\n",(0,r.jsx)(i.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,r.jsx)(i.p,{children:"In the following sections, we'll explore each type of pipeline in more detail:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.a,{href:"/android-kraft-shade/docs/pipeline-dsl/serial-pipeline",children:"Serial Pipeline"}),": Learn how to create linear processing chains"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.a,{href:"/android-kraft-shade/docs/pipeline-dsl/graph-pipeline",children:"Graph Pipeline"}),": Discover how to build complex multi-pass rendering graphs"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.a,{href:"/android-kraft-shade/docs/pipeline-dsl/nested-pipeline",children:"Nested Pipeline"}),": See how to combine serial and graph pipelines"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.a,{href:"/android-kraft-shade/docs/pipeline-dsl/pipeline-modifier",children:"PipelineModifier"}),": Create reusable pipeline components"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.a,{href:"/android-kraft-shade/docs/pipeline-dsl/best-practices",children:"Best Practices"}),": Tips for effective pipeline design"]}),"\n"]})]})}function c(e={}){const{wrapper:i}={...(0,t.R)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>a,x:()=>l});var s=n(6540);const r={},t=s.createContext(r);function a(e){const i=s.useContext(t);return s.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function l(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(t.Provider,{value:i},e.children)}}}]);