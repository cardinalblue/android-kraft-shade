"use strict";(self.webpackChunkdoc_website=self.webpackChunkdoc_website||[]).push([[1905],{3648:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>p,frontMatter:()=>l,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"core-components/input-system","title":"Input System","description":"The Input System is a core component of the Kraft Shade framework that provides a flexible and powerful mechanism for handling various types of inputs in shader pipelines. It enables dynamic parameter control, animation, and interactive effects by abstracting input sources and providing a consistent interface for accessing input values.","source":"@site/docs/core-components/input-system.md","sourceDirName":"core-components","slug":"/core-components/input-system","permalink":"/android-kraft-shade/docs/core-components/input-system","draft":false,"unlisted":false,"editUrl":"https://github.com/cardinalblue/android-kraft-shade/tree/main/doc_website/docs/core-components/input-system.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Buffer Management","permalink":"/android-kraft-shade/docs/core-components/pipeline-system/buffer-management"},"next":{"title":"View Components","permalink":"/android-kraft-shade/docs/view-components/"}}');var s=i(4848),a=i(8453);const l={sidebar_position:4},r="Input System",o={},c=[{value:"Overview",id:"overview",level:2},{value:"Input Types",id:"input-types",level:2},{value:"Base Input Class",id:"base-input-class",level:3},{value:"Immutable Inputs",id:"immutable-inputs",level:3},{value:"Sampled Inputs",id:"sampled-inputs",level:3},{value:"Time Input",id:"time-input",level:3},{value:"Dynamic Inputs",id:"dynamic-inputs",level:2},{value:"Understanding the Sampling Mechanism",id:"understanding-the-sampling-mechanism",level:3},{value:"Creating Custom Sampled Inputs",id:"creating-custom-sampled-inputs",level:3},{value:"Using TimeInput for Animations",id:"using-timeinput-for-animations",level:3},{value:"Input Transformations",id:"input-transformations",level:2},{value:"Mapping Inputs",id:"mapping-inputs",level:3},{value:"Utility Transformations",id:"utility-transformations",level:3},{value:"Scale",id:"scale",level:4},{value:"Bounce Between",id:"bounce-between",level:4},{value:"Chaining Transformations",id:"chaining-transformations",level:3},{value:"Creating Custom Transformations",id:"creating-custom-transformations",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"When to Use Different Input Types",id:"when-to-use-different-input-types",level:3},{value:"Performance Considerations",id:"performance-considerations",level:3},{value:"Integration with Shaders",id:"integration-with-shaders",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"input-system",children:"Input System"})}),"\n",(0,s.jsx)(n.p,{children:"The Input System is a core component of the Kraft Shade framework that provides a flexible and powerful mechanism for handling various types of inputs in shader pipelines. It enables dynamic parameter control, animation, and interactive effects by abstracting input sources and providing a consistent interface for accessing input values."}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(n.p,{children:"In graphics programming, shaders often require various inputs to control their behavior - from simple parameters like intensity or color to more complex inputs like time or user interactions. The Kraft Shade Input System addresses these needs by providing:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"A unified interface for all types of inputs"}),"\n",(0,s.jsx)(n.li,{children:"Support for both constant and dynamically changing values"}),"\n",(0,s.jsx)(n.li,{children:"Efficient caching and dirty state management for performance"}),"\n",(0,s.jsx)(n.li,{children:"Transformation capabilities to modify input values"}),"\n",(0,s.jsx)(n.li,{children:"Integration with the Pipeline system for frame-based processing"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The Input System is designed to be both simple to use for common cases and flexible enough for complex scenarios. It plays a crucial role in creating dynamic, interactive visual effects by connecting external data sources to shader parameters."}),"\n",(0,s.jsx)(n.h2,{id:"input-types",children:"Input Types"}),"\n",(0,s.jsxs)(n.p,{children:["The Input System supports various types of inputs that can be used in shader pipelines. At its core is the abstract ",(0,s.jsx)(n.code,{children:"Input<T>"})," class, which serves as the base for all input implementations."]}),"\n",(0,s.jsx)(n.h3,{id:"base-input-class",children:"Base Input Class"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"Input<T>"})," class is the foundation of the input system:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"abstract class Input<T : Any> {\n    internal abstract fun Pipeline.internalGet(): T\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["This abstract class defines a generic type parameter ",(0,s.jsx)(n.code,{children:"T"})," that represents the type of value the input provides. All input implementations extend this class and implement the ",(0,s.jsx)(n.code,{children:"internalGet()"})," function, which is an extension function on ",(0,s.jsx)(n.code,{children:"Pipeline"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"immutable-inputs",children:"Immutable Inputs"}),"\n",(0,s.jsx)(n.p,{children:"Immutable inputs provide constant values that don't change during the lifetime of a pipeline. They're useful for fixed parameters that don't need to be updated dynamically."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"class ImmutableInput<T : Any>(\n    private val value: T\n) : Input<T>() {\n    override fun Pipeline.internalGet(): T {\n        return value\n    }\n}\n\n// Helper function to create immutable inputs\nfun <T : Any> constInput(value: T) = ImmutableInput(value)\n"})}),"\n",(0,s.jsx)(n.p,{children:"Example usage:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"// Create a constant float input with value 0.5\nval intensity = constInput(0.5f)\n"})}),"\n",(0,s.jsx)(n.h3,{id:"sampled-inputs",children:"Sampled Inputs"}),"\n",(0,s.jsx)(n.p,{children:"Sampled inputs provide values that can change over time. They implement a caching mechanism to ensure consistent values within the same frame and only recalculate when necessary."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"abstract class SampledInput<T : Any> : Input<T>() {\n    private var lastSample: T? = null\n    private var isDirty: Boolean = true\n\n    protected abstract fun Pipeline.provideSample(): T\n\n    override fun Pipeline.internalGet(): T {\n        trackInput(this@SampledInput)\n        if (isDirty) {\n            lastSample = provideSample()\n            isDirty = false\n        }\n        return lastSample!!\n    }\n\n    internal open fun markDirty() {\n        isDirty = true\n    }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"SampledInput"})," class:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Maintains a cache of the last sampled value"}),"\n",(0,s.jsx)(n.li,{children:'Tracks whether the input is "dirty" and needs to be resampled'}),"\n",(0,s.jsxs)(n.li,{children:["Provides a ",(0,s.jsx)(n.code,{children:"markDirty()"})," method that's called at the beginning of each frame"]}),"\n",(0,s.jsxs)(n.li,{children:["Requires subclasses to implement ",(0,s.jsx)(n.code,{children:"provideSample()"})," to generate new values"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["A convenient way to create sampled inputs is using the ",(0,s.jsx)(n.code,{children:"sampledInput"})," function:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"fun <T : Any> sampledInput(action: PipelineRunningScope.() -> T) : SampledInput<T> {\n    return WrappedSampledInput(action)\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Example usage:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"// Create a sampled input that provides a random value each frame\nval randomValue = sampledInput { Math.random().toFloat() }\n"})}),"\n",(0,s.jsx)(n.h3,{id:"time-input",children:"Time Input"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"TimeInput"})," class is a specialized ",(0,s.jsx)(n.code,{children:"SampledInput"})," that provides time-based values, useful for animations and time-dependent effects:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"class TimeInput(\n    private val getTime: () -> Long = { System.currentTimeMillis() }\n) : SampledInput<Float>() {\n    // Implementation details...\n    \n    fun reset() { /* ... */ }\n    fun start() { /* ... */ }\n    fun pause() { /* ... */ }\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"TimeInput"})," class:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Provides the elapsed time in seconds as a Float"}),"\n",(0,s.jsx)(n.li,{children:"Supports starting, pausing, and resetting the timer"}),"\n",(0,s.jsx)(n.li,{children:"Can be customized with a custom time source for testing"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Example usage:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"// Create a time input and start it\nval time = CommonInputs.time()\n\n// Create a paused time input\nval pausedTime = CommonInputs.time(start = false)\npausedTime.start() // Start it later\n"})}),"\n",(0,s.jsx)(n.h2,{id:"dynamic-inputs",children:"Dynamic Inputs"}),"\n",(0,s.jsx)(n.p,{children:"Dynamic inputs allow for runtime changes to shader parameters and behaviors. They're essential for creating interactive and animated effects."}),"\n",(0,s.jsx)(n.h3,{id:"understanding-the-sampling-mechanism",children:"Understanding the Sampling Mechanism"}),"\n",(0,s.jsx)(n.p,{children:"Sampled inputs use a sophisticated mechanism to ensure efficient and consistent value provision:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:'At the beginning of each frame, all sampled inputs are marked as "dirty"'}),"\n",(0,s.jsxs)(n.li,{children:["When a sampled input's value is requested for the first time in a frame:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The input checks if it's dirty"}),"\n",(0,s.jsxs)(n.li,{children:["If dirty, it calls ",(0,s.jsx)(n.code,{children:"provideSample()"})," to get a new value and caches it"]}),"\n",(0,s.jsx)(n.li,{children:"The dirty flag is cleared"}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:"Subsequent requests within the same frame return the cached value"}),"\n",(0,s.jsx)(n.li,{children:"This ensures that even if an input is used multiple times in a frame, the value remains consistent"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["This mechanism is particularly important for inputs like ",(0,s.jsx)(n.code,{children:"TimeInput"})," where consistent values within a frame are crucial for correct rendering."]}),"\n",(0,s.jsx)(n.h3,{id:"creating-custom-sampled-inputs",children:"Creating Custom Sampled Inputs"}),"\n",(0,s.jsxs)(n.p,{children:["You can create custom sampled inputs by extending the ",(0,s.jsx)(n.code,{children:"SampledInput"})," class:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"class MyCustomInput : SampledInput<Float>() {\n    private var value = 0f\n    \n    override fun Pipeline.provideSample(): Float {\n        // Increment the value each frame\n        value += 0.01f\n        return value\n    }\n    \n    // Additional methods as needed\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Or more simply using the ",(0,s.jsx)(n.code,{children:"sampledInput"})," function:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"var counter = 0f\nval incrementingValue = sampledInput {\n    counter += 0.01f\n    counter\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"using-timeinput-for-animations",children:"Using TimeInput for Animations"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"TimeInput"})," class is particularly useful for creating animations:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'// Create a time input\nval time = CommonInputs.time()\n\n// Use it in a shader\nshader.setUniform("time", time)\n'})}),"\n",(0,s.jsx)(n.p,{children:"This allows creating effects that change over time, such as:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Oscillating parameters"}),"\n",(0,s.jsx)(n.li,{children:"Animated transitions"}),"\n",(0,s.jsx)(n.li,{children:"Procedural animations"}),"\n",(0,s.jsx)(n.li,{children:"Time-based color changes"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"input-transformations",children:"Input Transformations"}),"\n",(0,s.jsx)(n.p,{children:"Input transformations enable the modification and processing of input values before they are used in shaders. This allows for creating complex behaviors from simple inputs."}),"\n",(0,s.jsx)(n.h3,{id:"mapping-inputs",children:"Mapping Inputs"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"map"})," extension function allows transforming the value of any input:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"fun <T : Any, R : Any> Input<T>.map(mapper: (T) -> R): Input<R>\n"})}),"\n",(0,s.jsx)(n.p,{children:"This function automatically chooses the appropriate implementation based on the input type:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["For regular inputs, it returns a ",(0,s.jsx)(n.code,{children:"MappedInput"})]}),"\n",(0,s.jsxs)(n.li,{children:["For sampled inputs, it returns a ",(0,s.jsx)(n.code,{children:"MappedSampledInput"})," to preserve the sampling behavior"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Example usage:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"// Create a time input\nval time = CommonInputs.time()\n\n// Map it to a sine wave oscillating between 0 and 1\nval oscillator = time.map { sin(it * Math.PI.toFloat() * 2) * 0.5f + 0.5f }\n"})}),"\n",(0,s.jsx)(n.h3,{id:"utility-transformations",children:"Utility Transformations"}),"\n",(0,s.jsx)(n.p,{children:"The input system provides several utility transformations:"}),"\n",(0,s.jsx)(n.h4,{id:"scale",children:"Scale"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"fun Input<Float>.scale(scale: Float): Input<Float>\n"})}),"\n",(0,s.jsx)(n.p,{children:"Multiplies the input value by a constant factor."}),"\n",(0,s.jsx)(n.p,{children:"Example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"// Create a time input that runs twice as fast\nval fastTime = CommonInputs.time().scale(2f)\n"})}),"\n",(0,s.jsx)(n.h4,{id:"bounce-between",children:"Bounce Between"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"fun Input<Float>.bounceBetween(value1: Float, value2: Float): Input<Float>\n"})}),"\n",(0,s.jsx)(n.p,{children:"Creates an input that oscillates between two values."}),"\n",(0,s.jsx)(n.p,{children:"Example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"// Create an input that bounces between 0 and 1\nval bouncing = CommonInputs.time().bounceBetween(0f, 1f)\n"})}),"\n",(0,s.jsx)(n.h3,{id:"chaining-transformations",children:"Chaining Transformations"}),"\n",(0,s.jsx)(n.p,{children:"Transformations can be chained to create complex behaviors:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"// Create a time input\nval time = CommonInputs.time()\n\n// Create a value that oscillates between 0.2 and 0.8 at half speed\nval oscillator = time\n    .scale(0.5f)\n    .map { sin(it * Math.PI.toFloat() * 2) * 0.3f + 0.5f }\n"})}),"\n",(0,s.jsx)(n.h3,{id:"creating-custom-transformations",children:"Creating Custom Transformations"}),"\n",(0,s.jsxs)(n.p,{children:["You can create custom transformations by implementing extension functions on ",(0,s.jsx)(n.code,{children:"Input<T>"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"fun Input<Float>.squared(): Input<Float> = map { it * it }\n\nfun Input<Float>.clamp(min: Float, max: Float): Input<Float> = \n    map { kotlin.math.max(min, kotlin.math.min(it, max)) }\n"})}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsx)(n.h3,{id:"when-to-use-different-input-types",children:"When to Use Different Input Types"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Use ",(0,s.jsx)(n.code,{children:"ImmutableInput"})," (via ",(0,s.jsx)(n.code,{children:"constInput()"}),") for values that don't change"]}),"\n",(0,s.jsxs)(n.li,{children:["Use ",(0,s.jsx)(n.code,{children:"SampledInput"})," (via ",(0,s.jsx)(n.code,{children:"sampledInput()"}),") for values that need to be recalculated each frame"]}),"\n",(0,s.jsxs)(n.li,{children:["Use ",(0,s.jsx)(n.code,{children:"TimeInput"})," (via ",(0,s.jsx)(n.code,{children:"CommonInputs.time()"}),") for time-based animations"]}),"\n",(0,s.jsx)(n.li,{children:"Use transformations to derive complex behaviors from simple inputs"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Sampled inputs recalculate their values only once per frame, even if accessed multiple times"}),"\n",(0,s.jsxs)(n.li,{children:["Complex calculations in ",(0,s.jsx)(n.code,{children:"provideSample()"})," methods should be optimized"]}),"\n",(0,s.jsx)(n.li,{children:"Consider caching expensive calculations even across frames if appropriate"}),"\n",(0,s.jsx)(n.li,{children:"Be mindful of creating too many input transformations in performance-critical code"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"integration-with-shaders",children:"Integration with Shaders"}),"\n",(0,s.jsx)(n.p,{children:"Inputs are typically used to set shader uniforms:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'// Create inputs\nval time = CommonInputs.time()\nval intensity = constInput(0.8f)\n\n// Use them in a shader\nshader.setUniform("time", time)\nshader.setUniform("intensity", intensity)\n'})}),"\n",(0,s.jsx)(n.p,{children:"This creates a dynamic connection between the inputs and the shader, allowing the shader's behavior to change based on the input values."})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>r});var t=i(6540);const s={},a=t.createContext(s);function l(e){const n=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);