"use strict";(self.webpackChunkdoc_website=self.webpackChunkdoc_website||[]).push([[2052],{8453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>a});var r=i(6540);const s={},t=r.createContext(s);function l(e){const n=r.useContext(t);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),r.createElement(t.Provider,{value:n},e.children)}},9949:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>p,contentTitle:()=>a,default:()=>h,frontMatter:()=>l,metadata:()=>r,toc:()=>o});const r=JSON.parse('{"id":"pipeline-dsl/nested-pipeline","title":"Nested Pipeline","description":"Nested Pipelines in KraftShade allow you to combine the features of Serial and Graph Pipelines, creating modular and reusable pipeline components. This approach enables you to build complex effects by composing simpler ones, improving code organization and reusability.","source":"@site/docs/pipeline-dsl/nested-pipeline.md","sourceDirName":"pipeline-dsl","slug":"/pipeline-dsl/nested-pipeline","permalink":"/android-kraft-shade/docs/pipeline-dsl/nested-pipeline","draft":false,"unlisted":false,"editUrl":"https://github.com/cardinalblue/android-kraft-shade/tree/main/doc_website/docs/pipeline-dsl/nested-pipeline.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Graph Pipeline","permalink":"/android-kraft-shade/docs/pipeline-dsl/graph-pipeline"},"next":{"title":"PipelineModifier","permalink":"/android-kraft-shade/docs/pipeline-dsl/pipeline-modifier"}}');var s=i(4848),t=i(8453);const l={sidebar_position:4},a="Nested Pipeline",p={},o=[{value:"Understanding Nested Pipelines",id:"understanding-nested-pipelines",level:2},{value:"Types of Nested Pipelines",id:"types-of-nested-pipelines",level:2},{value:"1. Serial Steps within Graph Pipeline",id:"1-serial-steps-within-graph-pipeline",level:3},{value:"2. Graph Step within Serial Pipeline",id:"2-graph-step-within-serial-pipeline",level:3},{value:"3. Serial Step within Serial Pipeline",id:"3-serial-step-within-serial-pipeline",level:3},{value:"Implementation Details",id:"implementation-details",level:2},{value:"In <code>BasePipelineSetupScope</code>",id:"in-basepipelinesetupscope",level:3},{value:"In <code>SerialTextureInputPipelineScope</code>",id:"in-serialtextureinputpipelinescope",level:3},{value:"Real-World Example: Complex Photo Filter",id:"real-world-example-complex-photo-filter",level:2},{value:"Best Practices for Nested Pipelines",id:"best-practices-for-nested-pipelines",level:2},{value:"Limitations and Considerations",id:"limitations-and-considerations",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"nested-pipeline",children:"Nested Pipeline"})}),"\n",(0,s.jsx)(n.p,{children:"Nested Pipelines in KraftShade allow you to combine the features of Serial and Graph Pipelines, creating modular and reusable pipeline components. This approach enables you to build complex effects by composing simpler ones, improving code organization and reusability."}),"\n",(0,s.jsx)(n.h2,{id:"understanding-nested-pipelines",children:"Understanding Nested Pipelines"}),"\n",(0,s.jsx)(n.p,{children:"Nested pipelines are ideal for:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Building complex effects from simpler components"}),"\n",(0,s.jsx)(n.li,{children:"Creating reusable effect modules"}),"\n",(0,s.jsx)(n.li,{children:"Organizing complex rendering logic into manageable pieces"}),"\n",(0,s.jsx)(n.li,{children:"Combining the linear flow of serial pipelines with the flexibility of graph pipelines"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The key characteristic of nested pipelines is their hierarchical structure - pipelines can contain other pipelines, allowing for modular composition of effects."}),"\n",(0,s.jsx)(n.h2,{id:"types-of-nested-pipelines",children:"Types of Nested Pipelines"}),"\n",(0,s.jsx)(n.p,{children:"KraftShade supports two main types of nested pipelines:"}),"\n",(0,s.jsx)(n.h3,{id:"1-serial-steps-within-graph-pipeline",children:"1. Serial Steps within Graph Pipeline"}),"\n",(0,s.jsxs)(n.p,{children:["You can include a serial pipeline within a graph pipeline using the ",(0,s.jsx)(n.code,{children:"serialSteps"})," function:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'graphSteps(targetBuffer = windowSurface) {\n    // Create a buffer for the serial pipeline result\n    val (serialResult) = createBufferReferences("serial-result")\n    \n    // Some graph steps...\n    \n    // Nested serial pipeline\n    serialSteps(\n        inputTexture = sourceTexture,\n        targetBuffer = serialResult\n    ) {\n        // Serial steps defined here\n        step(ContrastKraftShader()) { shader ->\n            shader.contrast = 1.5f\n        }\n        \n        step(SaturationKraftShader()) { shader ->\n            shader.saturation = 0.8f\n        }\n    }\n    \n    // Continue with more graph steps using serialResult...\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"This allows you to create a linear sequence of operations within your graph pipeline."}),"\n",(0,s.jsx)(n.h3,{id:"2-graph-step-within-serial-pipeline",children:"2. Graph Step within Serial Pipeline"}),"\n",(0,s.jsxs)(n.p,{children:["You can include a graph pipeline within a serial pipeline using the ",(0,s.jsx)(n.code,{children:"graphStep"})," function:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'serialSteps(inputTexture = bitmap.asTexture(), targetBuffer = windowSurface) {\n    // Some serial steps...\n    \n    // Nested graph step\n    graphStep { inputTexture ->\n        // Graph operations defined here, using inputTexture as source\n        // and graphTargetBuffer as the output\n        \n        val (blurBuffer) = createBufferReferences("blur-buffer")\n        \n        stepWithInputTexture(\n            shader = BlurKraftShader(),\n            inputTexture = inputTexture,\n            targetBuffer = blurBuffer\n        )\n        \n        stepWithInputTexture(\n            shader = VignetteKraftShader(),\n            inputTexture = blurBuffer,\n            targetBuffer = graphTargetBuffer\n        )\n    }\n    \n    // Continue with more serial steps...\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"This allows you to create a complex, non-linear processing graph within your serial pipeline."}),"\n",(0,s.jsx)(n.h3,{id:"3-serial-step-within-serial-pipeline",children:"3. Serial Step within Serial Pipeline"}),"\n",(0,s.jsxs)(n.p,{children:["You can also nest a serial pipeline within another serial pipeline using the ",(0,s.jsx)(n.code,{children:"serialStep"})," function:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"serialSteps(inputTexture = bitmap.asTexture(), targetBuffer = windowSurface) {\n    // Some serial steps...\n    \n    // Nested serial step\n    serialStep {\n        // Another serial pipeline using serialStartTexture as input\n        // and serialTargetBuffer as output\n        step(ContrastKraftShader()) { shader ->\n            shader.contrast = 1.5f\n        }\n        \n        step(SaturationKraftShader()) { shader ->\n            shader.saturation = 0.8f\n        }\n    }\n    \n    // Continue with more serial steps...\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"This is useful for organizing related effects into logical groups."}),"\n",(0,s.jsx)(n.h2,{id:"implementation-details",children:"Implementation Details"}),"\n",(0,s.jsxs)(n.p,{children:["The nesting capabilities are implemented through the following methods in the ",(0,s.jsx)(n.code,{children:"PipelineDSL.kt"})," file:"]}),"\n",(0,s.jsxs)(n.h3,{id:"in-basepipelinesetupscope",children:["In ",(0,s.jsx)(n.code,{children:"BasePipelineSetupScope"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"@KraftShadeDsl\nopen suspend fun graphSteps(\n    targetBuffer: GlBufferProvider,\n    block: suspend GraphPipelineSetupScope.() -> Unit\n) {\n    val scope = GraphPipelineSetupScope(env, pipeline, targetBuffer)\n    block(scope)\n}\n\n@KraftShadeDsl\nopen suspend fun serialSteps(\n    inputTexture: TextureProvider,\n    targetBuffer: GlBufferProvider,\n    block: suspend SerialTextureInputPipelineScope.() -> Unit\n) {\n    val scope = SerialTextureInputPipelineScope(\n        currentStepIndex = pipeline.stepCount,\n        env = env,\n        pipeline = pipeline,\n        serialStartTexture = inputTexture,\n        serialTargetBuffer = targetBuffer\n    )\n\n    // we have to do it in two steps, because before the block is finished. We don't know which\n    // of the step is the last step that we have to draw to the target buffer.\n    scope.block()\n    scope.applyToPipeline()\n}\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"in-serialtextureinputpipelinescope",children:["In ",(0,s.jsx)(n.code,{children:"SerialTextureInputPipelineScope"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:"@KraftShadeDsl\nsuspend fun graphStep(\n    block: suspend GraphPipelineSetupScope.(inputTexture: TextureProvider) -> Unit\n) {\n    steps.add(InternalGraphStep(block))\n}\n\n@KraftShadeDsl\nsuspend fun serialStep(block: suspend SerialTextureInputPipelineScope.() -> Unit) {\n    steps.add(InternalSerialStep(block))\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"real-world-example-complex-photo-filter",children:"Real-World Example: Complex Photo Filter"}),"\n",(0,s.jsx)(n.p,{children:"Here's a complete example that implements a complex photo filter using nested pipelines:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'pipeline(windowSurface) {\n    serialSteps(\n        inputTexture = bitmap.asTexture(),\n        targetBuffer = windowSurface\n    ) {\n        // Apply basic color adjustments\n        step(ContrastKraftShader()) { shader ->\n            shader.contrast = 1.2f\n        }\n        \n        step(SaturationKraftShader()) { shader ->\n            shader.saturation = 0.9f\n        }\n        \n        // Apply a complex blur effect using a nested graph step\n        graphStep { inputTexture ->\n            // Create buffer references for the blur passes\n            val (horizontalBlurBuffer, verticalBlurBuffer) = createBufferReferences(\n                "horizontal-blur",\n                "vertical-blur"\n            )\n            \n            // First pass: horizontal blur\n            stepWithInputTexture(\n                shader = GaussianBlurKraftShader(),\n                inputTexture = inputTexture,\n                targetBuffer = horizontalBlurBuffer\n            ) { shader ->\n                shader.blurSize = 5f\n                shader.horizontal = true\n            }\n            \n            // Second pass: vertical blur\n            stepWithInputTexture(\n                shader = GaussianBlurKraftShader(),\n                inputTexture = horizontalBlurBuffer,\n                targetBuffer = verticalBlurBuffer\n            ) { shader ->\n                shader.blurSize = 5f\n                shader.horizontal = false\n            }\n            \n            // Blend the blurred result with the original\n            stepWithInputTexture(\n                shader = AlphaBlendKraftShader(),\n                inputTexture = inputTexture,\n                targetBuffer = graphTargetBuffer\n            ) { shader ->\n                shader.setSecondInputTexture(verticalBlurBuffer)\n                shader.mixturePercent = 0.7f\n            }\n        }\n        \n        // Apply final artistic effects\n        serialStep {\n            step(CrosshatchKraftShader()) { shader ->\n                shader.crossHatchSpacing = 0.03f\n                shader.lineWidth = 0.002f\n            }\n            \n            stepWithMixture(\n                shader = CrosshatchKraftShader(),\n                mixturePercentInput = constInput(0.5f)\n            ) { shader ->\n                shader.crossHatchSpacing = 0.05f\n                shader.lineWidth = 0.003f\n            }\n        }\n    }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"This example demonstrates:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"A top-level serial pipeline for the overall effect"}),"\n",(0,s.jsx)(n.li,{children:"A nested graph step for a complex blur effect"}),"\n",(0,s.jsx)(n.li,{children:"A nested serial step for artistic effects"}),"\n",(0,s.jsx)(n.li,{children:"Reuse of intermediate results within the nested pipelines"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"best-practices-for-nested-pipelines",children:"Best Practices for Nested Pipelines"}),"\n",(0,s.jsx)(n.p,{children:"When working with nested pipelines, consider these best practices:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Modular Design"}),": Use nested pipelines to create modular, reusable effect components."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Logical Grouping"}),": Group related operations into nested pipelines to improve code organization."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Appropriate Nesting"}),": Choose the right type of nesting based on your needs:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Use ",(0,s.jsx)(n.code,{children:"serialStep"})," for linear sequences of operations"]}),"\n",(0,s.jsxs)(n.li,{children:["Use ",(0,s.jsx)(n.code,{children:"graphStep"})," for complex, non-linear operations"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Buffer Management"}),": Be mindful of buffer usage in nested pipelines, especially in complex graphs."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Performance Considerations"}),": Nested pipelines can introduce additional overhead, so use them judiciously."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"limitations-and-considerations",children:"Limitations and Considerations"}),"\n",(0,s.jsx)(n.p,{children:"When using nested pipelines, be aware of these limitations:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Error Handling"}),": The ",(0,s.jsx)(n.code,{children:"serialSteps"})," method in a ",(0,s.jsx)(n.code,{children:"SerialTextureInputPipelineScope"})," is overridden to throw an error, directing you to use ",(0,s.jsx)(n.code,{children:"serialStep"})," instead:"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-kotlin",children:'@DangerousKraftShadeApi\n@KraftShadeDsl\noverride suspend fun serialSteps(\n    inputTexture: TextureProvider,\n    targetBuffer: GlBufferProvider,\n    block: suspend SerialTextureInputPipelineScope.() -> Unit\n) {\n    error("please use graphStep instead of serialSteps in serial scope")\n}\n'})}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Buffer Lifecycle"}),": Buffers created in nested pipelines are managed by the parent pipeline, so be careful about buffer references that cross pipeline boundaries."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Complexity"}),": While nested pipelines offer great flexibility, they can also make your code more complex and harder to debug. Use them when the benefits of modularity outweigh the added complexity."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,s.jsx)(n.p,{children:"Now that you understand how to create and use nested pipelines, you might want to explore:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"/android-kraft-shade/docs/pipeline-dsl/best-practices",children:"Best Practices"})," for pipeline design"]}),"\n",(0,s.jsx)(n.li,{children:"Advanced techniques for optimizing pipeline performance"}),"\n",(0,s.jsx)(n.li,{children:"Creating reusable effect modules using nested pipelines"}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);