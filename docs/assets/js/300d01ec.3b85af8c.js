"use strict";(self.webpackChunkdoc_website=self.webpackChunkdoc_website||[]).push([[4395],{8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>d});var i=t(6540);const a={},s=i.createContext(a);function r(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(s.Provider,{value:n},e.children)}},9423:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>d,default:()=>u,frontMatter:()=>r,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"view-components/android-views/animated-kraft-texture-view","title":"AnimatedKraftTextureView","description":"AnimatedKraftTextureView extends KraftEffectTextureView to provide animation capabilities for shader effects.","source":"@site/docs/view-components/android-views/animated-kraft-texture-view.md","sourceDirName":"view-components/android-views","slug":"/view-components/android-views/animated-kraft-texture-view","permalink":"/android-kraft-shade/docs/view-components/android-views/animated-kraft-texture-view","draft":false,"unlisted":false,"editUrl":"https://github.com/cardinalblue/android-kraft-shade/tree/main/doc_website/docs/view-components/android-views/animated-kraft-texture-view.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"KraftEffectTextureView","permalink":"/android-kraft-shade/docs/view-components/android-views/kraft-effect-texture-view"},"next":{"title":"KraftVideoEffectTextureView","permalink":"/android-kraft-shade/docs/view-components/android-views/kraft-video-effect-texture-view"}}');var a=t(4848),s=t(8453);const r={sidebar_position:3},d="AnimatedKraftTextureView",o={},c=[{value:"Overview",id:"overview",level:2},{value:"Key Features",id:"key-features",level:2},{value:"Basic Usage",id:"basic-usage",level:2},{value:"Important Methods",id:"important-methods",level:2},{value:"Setting Up Animations",id:"setting-up-animations",level:3},{value:"<code>setEffectWithTimeInput</code>",id:"seteffectwithtimeinput",level:4},{value:"<code>setEffectAndPlay</code>",id:"seteffectandplay",level:4},{value:"<code>setEffectAndPause</code>",id:"seteffectandpause",level:4},{value:"Animation Control",id:"animation-control",level:3},{value:"<code>play</code>",id:"play",level:4},{value:"<code>stop</code>",id:"stop",level:4},{value:"Properties",id:"properties",level:2},{value:"<code>timeInput</code>",id:"timeinput",level:3},{value:"<code>playing</code>",id:"playing",level:3},{value:"Example: Creating a Time-Based Animation",id:"example-creating-a-time-based-animation",level:2},{value:"Working with TimeInput",id:"working-with-timeinput",level:2},{value:"<code>bounceBetween</code>",id:"bouncebetween",level:3},{value:"<code>map</code>",id:"map",level:3},{value:"Considerations",id:"considerations",level:2},{value:"Next Steps",id:"next-steps",level:2}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"animatedkrafttextureview",children:"AnimatedKraftTextureView"})}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"AnimatedKraftTextureView"})," extends ",(0,a.jsx)(n.a,{href:"/android-kraft-shade/docs/view-components/android-views/kraft-effect-texture-view",children:"KraftEffectTextureView"})," to provide animation capabilities for shader effects."]}),"\n",(0,a.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"AnimatedKraftTextureView"})," is designed for creating time-based animations with shader effects. It builds on the effect rendering capabilities of ",(0,a.jsx)(n.code,{children:"KraftEffectTextureView"})," and adds animation control through Android's Choreographer for frame-synchronized rendering."]}),"\n",(0,a.jsx)(n.p,{children:"This view is ideal for applications that need to create dynamic, animated visual effects that change over time, such as transitions, procedural animations, or time-based visual effects."}),"\n",(0,a.jsx)(n.h2,{id:"key-features",children:"Key Features"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Frame-synchronized rendering using Android's Choreographer"}),"\n",(0,a.jsx)(n.li,{children:"Built-in play/pause controls for animation"}),"\n",(0,a.jsxs)(n.li,{children:["Integrated ",(0,a.jsx)(n.code,{children:"TimeInput"})," for time-based animations"]}),"\n",(0,a.jsx)(n.li,{children:"Specialized methods for setting up animated effects"}),"\n",(0,a.jsx)(n.li,{children:"Automatic frame skipping when rendering can't keep up with the frame rate"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,a.jsxs)(n.p,{children:["Here's a simple example of using ",(0,a.jsx)(n.code,{children:"AnimatedKraftTextureView"})," to create an animated saturation effect:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"class MyActivity : AppCompatActivity() {\n    private lateinit var animatedView: AnimatedKraftTextureView\n    \n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        \n        // Create the view\n        animatedView = AnimatedKraftTextureView(this)\n        setContentView(animatedView)\n        \n        // Load an image and set up an animated saturation effect\n        val bitmap = BitmapFactory.decodeResource(resources, R.drawable.my_image)\n        \n        animatedView.setEffectAndPlay { windowSurface, timeInput ->\n            // Create a pipeline with an animated saturation shader\n            val saturationInput = timeInput.bounceBetween(0f, 2f)\n            \n            pipeline(windowSurface) {\n                serialSteps(\n                    inputTexture = bitmap.asTexture(),\n                    targetBuffer = windowSurface\n                ) {\n                    step(SaturationKraftShader()) { shader ->\n                        shader.saturation = saturationInput.get()\n                    }\n                }\n            }\n        }\n    }\n    \n    override fun onPause() {\n        super.onPause()\n        animatedView.stop()  // Pause animation when activity is paused\n    }\n    \n    override fun onResume() {\n        super.onResume()\n        animatedView.play()  // Resume animation when activity is resumed\n    }\n    \n    override fun onDestroy() {\n        // Clean up resources\n        animatedView.terminate()\n        super.onDestroy()\n    }\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"important-methods",children:"Important Methods"}),"\n",(0,a.jsx)(n.h3,{id:"setting-up-animations",children:"Setting Up Animations"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"AnimatedKraftTextureView"})," provides several methods for setting up animated effects:"]}),"\n",(0,a.jsx)(n.h4,{id:"seteffectwithtimeinput",children:(0,a.jsx)(n.code,{children:"setEffectWithTimeInput"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"fun setEffectWithTimeInput(\n    afterSet: suspend GlEnvDslScope.(windowSurface: WindowSurfaceBuffer, timeInput: TimeInput) -> Unit = { _, _ -> },\n    effectExecutionProvider: AnimatedEffectExecutionProvider\n)\n"})}),"\n",(0,a.jsx)(n.p,{children:"This method:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Takes an ",(0,a.jsx)(n.code,{children:"AnimatedEffectExecutionProvider"})," that creates the effect execution pipeline with a ",(0,a.jsx)(n.code,{children:"TimeInput"})]}),"\n",(0,a.jsxs)(n.li,{children:["Optionally accepts an ",(0,a.jsx)(n.code,{children:"afterSet"})," lambda that runs after the effect is set"]}),"\n",(0,a.jsx)(n.li,{children:"Does not automatically start the animation"}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"seteffectandplay",children:(0,a.jsx)(n.code,{children:"setEffectAndPlay"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"fun setEffectAndPlay(effectExecutionProvider: AnimatedEffectExecutionProvider)\n"})}),"\n",(0,a.jsx)(n.p,{children:"This method:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Sets up the effect with the provided ",(0,a.jsx)(n.code,{children:"AnimatedEffectExecutionProvider"})]}),"\n",(0,a.jsx)(n.li,{children:"Automatically starts the animation after the effect is set"}),"\n"]}),"\n",(0,a.jsx)(n.h4,{id:"seteffectandpause",children:(0,a.jsx)(n.code,{children:"setEffectAndPause"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"fun setEffectAndPause(effectExecutionProvider: AnimatedEffectExecutionProvider)\n"})}),"\n",(0,a.jsx)(n.p,{children:"This method:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Sets up the effect with the provided ",(0,a.jsx)(n.code,{children:"AnimatedEffectExecutionProvider"})]}),"\n",(0,a.jsx)(n.li,{children:"Does not start the animation (remains paused)"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"animation-control",children:"Animation Control"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"AnimatedKraftTextureView"})," provides methods to control the animation playback:"]}),"\n",(0,a.jsx)(n.h4,{id:"play",children:(0,a.jsx)(n.code,{children:"play"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"fun play()\n"})}),"\n",(0,a.jsx)(n.p,{children:"Starts or resumes the animation."}),"\n",(0,a.jsx)(n.h4,{id:"stop",children:(0,a.jsx)(n.code,{children:"stop"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"fun stop()\n"})}),"\n",(0,a.jsx)(n.p,{children:"Pauses the animation."}),"\n",(0,a.jsx)(n.h2,{id:"properties",children:"Properties"}),"\n",(0,a.jsx)(n.h3,{id:"timeinput",children:(0,a.jsx)(n.code,{children:"timeInput"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"val timeInput: TimeInput\n"})}),"\n",(0,a.jsxs)(n.p,{children:["A ",(0,a.jsx)(n.code,{children:"TimeInput"})," instance that can be used to create time-based animations. This input automatically updates as the animation progresses."]}),"\n",(0,a.jsx)(n.h3,{id:"playing",children:(0,a.jsx)(n.code,{children:"playing"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"val playing: Boolean\n"})}),"\n",(0,a.jsx)(n.p,{children:"Indicates whether the animation is currently playing."}),"\n",(0,a.jsx)(n.h2,{id:"example-creating-a-time-based-animation",children:"Example: Creating a Time-Based Animation"}),"\n",(0,a.jsx)(n.p,{children:"This example shows how to create an animation that oscillates between different visual effects:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:'class MyAnimationActivity : AppCompatActivity() {\n    private lateinit var animatedView: AnimatedKraftTextureView\n    \n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_animation)\n        \n        animatedView = findViewById(R.id.animated_view)\n        val playPauseButton = findViewById<Button>(R.id.play_pause_button)\n        \n        val bitmap = BitmapFactory.decodeResource(resources, R.drawable.my_image)\n        \n        // Set up the animated effect\n        animatedView.setEffectWithTimeInput { windowSurface, timeInput ->\n            // Create time-based inputs for various effects\n            val saturationInput = timeInput.bounceBetween(0.5f, 1.5f, periodMs = 3000)\n            val contrastInput = timeInput.bounceBetween(0.8f, 1.2f, periodMs = 5000)\n            val hueRotationInput = timeInput.map { (it % 10000) / 10000f * 360f }\n            \n            pipeline(windowSurface) {\n                serialSteps(\n                    inputTexture = bitmap.asTexture(),\n                    targetBuffer = windowSurface\n                ) {\n                    step(SaturationKraftShader()) { shader ->\n                        shader.saturation = saturationInput.get()\n                    }\n                    \n                    step(ContrastKraftShader()) { shader ->\n                        shader.contrast = contrastInput.get()\n                    }\n                    \n                    step(HueKraftShader()) { shader ->\n                        shader.setHueInDegree(hueRotationInput.get())\n                    }\n                }\n            }\n            \n            // Start the animation\n            animatedView.play()\n        }\n        \n        // Set up play/pause button\n        playPauseButton.setOnClickListener {\n            if (animatedView.playing) {\n                animatedView.stop()\n                playPauseButton.text = "Play"\n            } else {\n                animatedView.play()\n                playPauseButton.text = "Pause"\n            }\n        }\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"working-with-timeinput",children:"Working with TimeInput"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"TimeInput"})," class provides several methods for creating time-based animations:"]}),"\n",(0,a.jsx)(n.h3,{id:"bouncebetween",children:(0,a.jsx)(n.code,{children:"bounceBetween"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"fun bounceBetween(min: Float, max: Float, periodMs: Long = 2000): SampledInput<Float>\n"})}),"\n",(0,a.jsx)(n.p,{children:"Creates an input that oscillates between the minimum and maximum values over the specified period."}),"\n",(0,a.jsx)(n.h3,{id:"map",children:(0,a.jsx)(n.code,{children:"map"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-kotlin",children:"fun <T> map(mapper: (Long) -> T): SampledInput<T>\n"})}),"\n",(0,a.jsx)(n.p,{children:"Creates a custom input by mapping the elapsed time to a value of type T."}),"\n",(0,a.jsx)(n.h2,{id:"considerations",children:"Considerations"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Animations run at the device's refresh rate (typically 60fps)"}),"\n",(0,a.jsx)(n.li,{children:"The animation automatically pauses when the view is detached from the window"}),"\n",(0,a.jsx)(n.li,{children:"For complex effects, monitor performance and consider simplifying shaders if frame drops occur"}),"\n",(0,a.jsxs)(n.li,{children:["Always call ",(0,a.jsx)(n.code,{children:"stop()"})," when the animation is not visible to conserve battery"]}),"\n",(0,a.jsxs)(n.li,{children:["For non-animated effects, use ",(0,a.jsx)(n.a,{href:"/android-kraft-shade/docs/view-components/android-views/kraft-effect-texture-view",children:"KraftEffectTextureView"})," instead"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,a.jsxs)(n.p,{children:["For Jetpack Compose integration, see ",(0,a.jsx)(n.a,{href:"/android-kraft-shade/docs/view-components/jetpack-compose/kraft-shade-animated-view",children:"KraftShadeAnimatedView"}),"."]})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}}}]);