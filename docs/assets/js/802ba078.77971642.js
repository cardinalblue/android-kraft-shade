"use strict";(self.webpackChunkdoc_website=self.webpackChunkdoc_website||[]).push([[3097],{7070:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>f,frontMatter:()=>s,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"view-components/jetpack-compose/kraft-shade-effect-view","title":"KraftShadeEffectView","description":"KraftShadeEffectView is a Jetpack Compose wrapper for KraftEffectTextureView, providing shader effect capabilities in Compose UIs.","source":"@site/docs/view-components/jetpack-compose/kraft-shade-effect-view.md","sourceDirName":"view-components/jetpack-compose","slug":"/view-components/jetpack-compose/kraft-shade-effect-view","permalink":"/android-kraft-shade/docs/view-components/jetpack-compose/kraft-shade-effect-view","draft":false,"unlisted":false,"editUrl":"https://github.com/cardinalblue/android-kraft-shade/tree/main/doc_website/docs/view-components/jetpack-compose/kraft-shade-effect-view.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"KraftShadeView","permalink":"/android-kraft-shade/docs/view-components/jetpack-compose/kraft-shade-view"},"next":{"title":"KraftShadeAnimatedView","permalink":"/android-kraft-shade/docs/view-components/jetpack-compose/kraft-shade-animated-view"}}');var i=n(4848),r=n(8453);const s={sidebar_position:2},o="KraftShadeEffectView",d={},c=[{value:"Overview",id:"overview",level:2},{value:"Key Features",id:"key-features",level:2},{value:"Basic Usage",id:"basic-usage",level:2},{value:"Components",id:"components",level:2},{value:"KraftShadeEffectView Composable",id:"kraftshadeeffectview-composable",level:3},{value:"KraftShadeEffectState",id:"kraftshadeeffectstate",level:3},{value:"rememberKraftShadeEffectState",id:"rememberkraftshadeeffectstate",level:3},{value:"Example: Multiple Effects with Controls",id:"example-multiple-effects-with-controls",level:2},{value:"Integration with Compose State",id:"integration-with-compose-state",level:2},{value:"Considerations",id:"considerations",level:2},{value:"Next Steps",id:"next-steps",level:2}];function l(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"kraftshadeeffectview",children:"KraftShadeEffectView"})}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"KraftShadeEffectView"})," is a Jetpack Compose wrapper for ",(0,i.jsx)(t.a,{href:"/android-kraft-shade/docs/view-components/android-views/kraft-effect-texture-view",children:"KraftEffectTextureView"}),", providing shader effect capabilities in Compose UIs."]}),"\n",(0,i.jsx)(t.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"KraftShadeEffectView"})," integrates the shader effect capabilities of ",(0,i.jsx)(t.code,{children:"KraftEffectTextureView"})," into Jetpack Compose applications. It builds on the foundation of ",(0,i.jsx)(t.a,{href:"/android-kraft-shade/docs/view-components/jetpack-compose/kraft-shade-view",children:"KraftShadeView"})," and adds functionality specifically for applying visual effects to images and other content."]}),"\n",(0,i.jsx)(t.p,{children:"This component is ideal for Compose applications that need to apply visual effects to images, with support for both one-time rendering and on-demand updates when effect parameters change."}),"\n",(0,i.jsx)(t.h2,{id:"key-features",children:"Key Features"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Integrates ",(0,i.jsx)(t.code,{children:"KraftEffectTextureView"})," into Jetpack Compose UIs"]}),"\n",(0,i.jsx)(t.li,{children:"Provides a state-based API for managing effects"}),"\n",(0,i.jsx)(t.li,{children:"Supports setting and updating shader effects"}),"\n",(0,i.jsx)(t.li,{children:"Allows on-demand rendering when effect parameters change"}),"\n",(0,i.jsx)(t.li,{children:"Handles proper resource cleanup with Compose's lifecycle"}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"basic-usage",children:"Basic Usage"}),"\n",(0,i.jsxs)(t.p,{children:["Here's a simple example of using ",(0,i.jsx)(t.code,{children:"KraftShadeEffectView"})," to apply a saturation effect to an image in a Compose UI:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-kotlin",children:'@Composable\nfun SaturationEffectDemo() {\n    // Create and remember the state\n    val state = rememberKraftShadeEffectState()\n    var saturation by remember { mutableFloatStateOf(1.0f) }\n    var aspectRatio by remember { mutableFloatStateOf(1f) }\n    val context = LocalContext.current\n    \n    Column(\n        modifier = Modifier.fillMaxSize(),\n        horizontalAlignment = Alignment.CenterHorizontally\n    ) {\n        // Render area\n        KraftShadeEffectView(\n            modifier = Modifier\n                .weight(1f)\n                .aspectRatio(aspectRatio),\n            state = state\n        )\n        \n        // Saturation control\n        Text("Saturation: ${saturation.format(1)}")\n        Slider(\n            value = saturation,\n            onValueChange = { \n                saturation = it\n                state.requestRender() // Request a render with the new saturation\n            },\n            valueRange = 0f..2f,\n            modifier = Modifier.padding(16.dp)\n        )\n    }\n    \n    // Set up the effect when the composition is first created\n    LaunchedEffect(Unit) {\n        state.setEffect { windowSurface ->\n            val bitmap = context.loadBitmapFromAsset("sample/cat.jpg")\n            aspectRatio = bitmap.width.toFloat() / bitmap.height\n            \n            pipeline(windowSurface) {\n                serialSteps(\n                    inputTexture = bitmap.asTexture(),\n                    targetBuffer = windowSurface\n                ) {\n                    step(SaturationKraftShader()) { shader ->\n                        shader.saturation = saturation\n                    }\n                }\n            }\n        }\n    }\n}\n\n// Helper extension function to format float values\nfun Float.format(digits: Int) = "%.${digits}f".format(this)\n'})}),"\n",(0,i.jsx)(t.h2,{id:"components",children:"Components"}),"\n",(0,i.jsx)(t.h3,{id:"kraftshadeeffectview-composable",children:"KraftShadeEffectView Composable"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-kotlin",children:"@Composable\nfun KraftShadeEffectView(\n    modifier: Modifier = Modifier,\n    state: KraftShadeEffectState = rememberKraftShadeEffectState()\n)\n"})}),"\n",(0,i.jsxs)(t.p,{children:["The main Composable function that creates a ",(0,i.jsx)(t.code,{children:"KraftEffectTextureView"})," and integrates it into your Compose UI."]}),"\n",(0,i.jsx)(t.p,{children:"Parameters:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"modifier"}),": Standard Compose modifier for customizing the view's layout"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"state"}),": A ",(0,i.jsx)(t.code,{children:"KraftShadeEffectState"})," that manages the view's state and operations"]}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"kraftshadeeffectstate",children:"KraftShadeEffectState"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-kotlin",children:"class KraftShadeEffectState(\n    scope: CoroutineScope,\n    var skipRender: Boolean = false\n)\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Manages the state of the ",(0,i.jsx)(t.code,{children:"KraftShadeEffectView"})," and provides methods to interact with it."]}),"\n",(0,i.jsx)(t.p,{children:"Key methods:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"setEffect(afterSet: suspend GlEnvDslScope.(windowSurface: WindowSurfaceBuffer) -> Unit = { requestRender() }, effectExecutionProvider: EffectExecutionProvider)"}),": Sets the effect to be applied"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"requestRender()"}),": Triggers a render with the current effect"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"setRenderOnSizeChange(enabled: Boolean)"}),": Controls whether rendering is automatically triggered when the view size changes"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"renderBlocking()"}),": Performs a blocking render (use with caution)"]}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"rememberkraftshadeeffectstate",children:"rememberKraftShadeEffectState"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-kotlin",children:"@Composable\nfun rememberKraftShadeEffectState(\n    skipRendering: Boolean = false,\n    renderOnSizeChange: Boolean = true\n): KraftShadeEffectState\n"})}),"\n",(0,i.jsxs)(t.p,{children:["A Compose helper function that creates and remembers a ",(0,i.jsx)(t.code,{children:"KraftShadeEffectState"})," instance, ensuring it survives recomposition."]}),"\n",(0,i.jsx)(t.p,{children:"Parameters:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"skipRendering"}),": When true, rendering requests will be ignored"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"renderOnSizeChange"}),": Controls whether rendering is automatically triggered when the view size changes"]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"example-multiple-effects-with-controls",children:"Example: Multiple Effects with Controls"}),"\n",(0,i.jsx)(t.p,{children:"This example shows how to apply multiple effects to an image with interactive controls:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-kotlin",children:'@Composable\nfun MultiEffectDemo() {\n    val state = rememberKraftShadeEffectState()\n    var aspectRatio by remember { mutableFloatStateOf(1f) }\n    var saturation by remember { mutableFloatStateOf(1f) }\n    var brightness by remember { mutableFloatStateOf(0f) }\n    var contrast by remember { mutableFloatStateOf(1f) }\n    val context = LocalContext.current\n    \n    Column(\n        modifier = Modifier.fillMaxSize(),\n        horizontalAlignment = Alignment.CenterHorizontally\n    ) {\n        // Render area\n        Box(\n            modifier = Modifier\n                .weight(1f)\n                .fillMaxWidth(),\n            contentAlignment = Alignment.Center\n        ) {\n            KraftShadeEffectView(\n                modifier = Modifier.aspectRatio(aspectRatio),\n                state = state\n            )\n        }\n        \n        // Effect controls\n        Column(\n            modifier = Modifier\n                .fillMaxWidth()\n                .padding(16.dp)\n        ) {\n            Text("Saturation")\n            Slider(\n                value = saturation,\n                onValueChange = { \n                    saturation = it\n                    state.requestRender()\n                },\n                valueRange = 0f..2f\n            )\n            \n            Text("Brightness")\n            Slider(\n                value = brightness,\n                onValueChange = { \n                    brightness = it\n                    state.requestRender()\n                },\n                valueRange = -1f..1f\n            )\n            \n            Text("Contrast")\n            Slider(\n                value = contrast,\n                onValueChange = { \n                    contrast = it\n                    state.requestRender()\n                },\n                valueRange = 0.5f..1.5f\n            )\n        }\n    }\n    \n    // Set up the effect\n    LaunchedEffect(Unit) {\n        state.setEffect { windowSurface ->\n            val bitmap = context.loadBitmapFromAsset("sample/cat.jpg")\n            aspectRatio = bitmap.width.toFloat() / bitmap.height\n            \n            pipeline(windowSurface) {\n                serialSteps(\n                    inputTexture = bitmap.asTexture(),\n                    targetBuffer = windowSurface\n                ) {\n                    step(SaturationKraftShader()) { shader ->\n                        shader.saturation = saturation\n                    }\n                    \n                    step(BrightnessKraftShader()) { shader ->\n                        shader.brightness = brightness\n                    }\n                    \n                    step(ContrastKraftShader()) { shader ->\n                        shader.contrast = contrast\n                    }\n                }\n            }\n        }\n    }\n}\n'})}),"\n",(0,i.jsx)(t.h2,{id:"integration-with-compose-state",children:"Integration with Compose State"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"KraftShadeEffectView"})," works well with Compose's state management system. You can:"]}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"Use Compose state variables to control shader parameters"}),"\n",(0,i.jsxs)(t.li,{children:["Call ",(0,i.jsx)(t.code,{children:"requestRender()"})," when state changes to update the visual effect"]}),"\n",(0,i.jsxs)(t.li,{children:["Use ",(0,i.jsx)(t.code,{children:"LaunchedEffect"})," to set up the initial effect"]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["For more advanced integration, you can use the ",(0,i.jsx)(t.code,{children:"asSampledInput()"})," extension function to convert Compose state to KraftShade inputs:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-kotlin",children:"@Composable\nfun ComposeStateIntegrationDemo() {\n    val state = rememberKraftShadeEffectState()\n    var saturation by remember { mutableFloatStateOf(1f) }\n    val saturationState = remember { mutableStateOf(1f) }\n    \n    // When using asSampledInput, changes to the state are automatically\n    // reflected in the shader without calling requestRender()\n    LaunchedEffect(saturation) {\n        saturationState.value = saturation\n    }\n    \n    // Set up the effect with the state-based input\n    LaunchedEffect(Unit) {\n        state.setEffect { windowSurface ->\n            pipeline(windowSurface) {\n                serialSteps(inputTexture, windowSurface) {\n                    step(SaturationKraftShader()) { shader ->\n                        // Use the Compose state as a shader input\n                        shader.saturation = saturationState.asSampledInput().get()\n                    }\n                }\n            }\n        }\n    }\n    \n    // UI components...\n}\n"})}),"\n",(0,i.jsx)(t.h2,{id:"considerations",children:"Considerations"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Effects are applied asynchronously in a coroutine context"}),"\n",(0,i.jsxs)(t.li,{children:["Always call ",(0,i.jsx)(t.code,{children:"requestRender()"})," after changing effect parameters (unless using ",(0,i.jsx)(t.code,{children:"asSampledInput()"}),")"]}),"\n",(0,i.jsxs)(t.li,{children:["For animated effects that change over time, use ",(0,i.jsx)(t.a,{href:"/android-kraft-shade/docs/view-components/jetpack-compose/kraft-shade-animated-view",children:"KraftShadeAnimatedView"})," instead"]}),"\n",(0,i.jsxs)(t.li,{children:["The ",(0,i.jsx)(t.code,{children:"skipRendering"})," parameter can be useful for temporarily disabling rendering during complex state changes"]}),"\n",(0,i.jsxs)(t.li,{children:["Setting ",(0,i.jsx)(t.code,{children:"renderOnSizeChange"})," to false can be useful when you want to control exactly when rendering occurs"]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,i.jsxs)(t.p,{children:["For animated effects in Compose, see ",(0,i.jsx)(t.a,{href:"/android-kraft-shade/docs/view-components/jetpack-compose/kraft-shade-animated-view",children:"KraftShadeAnimatedView"}),"."]})]})}function f(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>o});var a=n(6540);const i={},r=a.createContext(i);function s(e){const t=a.useContext(r);return a.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),a.createElement(r.Provider,{value:t},e.children)}}}]);