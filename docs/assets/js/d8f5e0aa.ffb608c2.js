"use strict";(self.webpackChunkdoc_website=self.webpackChunkdoc_website||[]).push([[8493],{2674:(e,t,n)=>{n.d(t,{$y:()=>s,Gd:()=>r});n(6540);var a=n(5260),i=n(4848);function r({title:e,description:t,url:n,datePublished:r="2025-01-01",dateModified:s=(new Date).toISOString().split("T")[0],articleSection:l="Documentation"}){const o={"@context":"https://schema.org","@type":"TechArticle",headline:e,description:t,url:n,datePublished:r,dateModified:s,articleSection:l,author:{"@type":"Organization",name:"Cardinal Blue Software",url:"https://cardinalblue.com"},publisher:{"@type":"Organization",name:"Cardinal Blue Software",url:"https://cardinalblue.com",logo:{"@type":"ImageObject",url:"https://cardinalblue.github.io/android-kraft-shade/img/logo.png"}},mainEntityOfPage:{"@type":"WebPage","@id":n},about:{"@type":"SoftwareApplication",name:"KraftShade",description:"Android OpenGL ES graphics rendering library"},genre:"Technology",keywords:["kotlin","android","opengl","graphics","documentation","kraftshade"],educationalLevel:"Intermediate",learningResourceType:"Documentation",inLanguage:"en"};return(0,i.jsx)(a.A,{children:(0,i.jsx)("script",{type:"application/ld+json",children:JSON.stringify(o,null,2)})})}function s({name:e,description:t,url:n,steps:r,totalTime:s="PT10M",supply:l=[]}){const o={"@context":"https://schema.org","@type":"HowTo",name:e,description:t,url:n,totalTime:s,supply:l.map(e=>({"@type":"HowToSupply",name:e})),step:r.map((e,t)=>({"@type":"HowToStep",position:t+1,name:`Step ${t+1}`,text:e})),author:{"@type":"Organization",name:"Cardinal Blue Software"},datePublished:"2025-01-01",dateModified:(new Date).toISOString().split("T")[0],inLanguage:"en",about:{"@type":"SoftwareApplication",name:"KraftShade"}};return(0,i.jsx)(a.A,{children:(0,i.jsx)("script",{type:"application/ld+json",children:JSON.stringify(o,null,2)})})}},5762:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>u,frontMatter:()=>l,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"getting-started/first-effect","title":"first-effect","description":"<HowToSchema","source":"@site/docs/getting-started/first-effect.md","sourceDirName":"getting-started","slug":"/getting-started/first-effect","permalink":"/android-kraft-shade/docs/getting-started/first-effect","draft":false,"unlisted":false,"editUrl":"https://github.com/cardinalblue/android-kraft-shade/tree/main/doc_website/docs/getting-started/first-effect.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Basic Concepts","permalink":"/android-kraft-shade/docs/getting-started/basic-concepts"},"next":{"title":"Core Components","permalink":"/android-kraft-shade/docs/core-components/"}}');var i=n(4848),r=n(8453),s=n(2674);const l={sidebar_position:4},o="First Effect",d={},c=[{value:"Prerequisites",id:"prerequisites",level:2},{value:"Project Setup",id:"project-setup",level:2},{value:"Creating a Vintage Photo Effect",id:"creating-a-vintage-photo-effect",level:2},{value:"Step 1: Set Up the UI",id:"step-1-set-up-the-ui",level:3},{value:"Step 2: Create the Effect Pipeline",id:"step-2-create-the-effect-pipeline",level:3},{value:"Step 3: Create a Custom Noise Overlay Shader",id:"step-3-create-a-custom-noise-overlay-shader",level:3},{value:"Understanding the Pipeline",id:"understanding-the-pipeline",level:2},{value:"Extending the Effect",id:"extending-the-effect",level:2},{value:"Adding Color Grading with LookUpTableKraftShader",id:"adding-color-grading-with-lookuptablekraftshader",level:3},{value:"Adding a Subtle Blur",id:"adding-a-subtle-blur",level:3},{value:"Using the Graph Pipeline for Complex Effects",id:"using-the-graph-pipeline-for-complex-effects",level:2},{value:"Serializing Your Effect",id:"serializing-your-effect",level:2},{value:"Next Steps",id:"next-steps",level:2}];function f(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.$y,{name:"Create Your First Effect with KraftShade",description:"Step-by-step guide to creating a vintage photo effect using KraftShade's pipeline system with multiple shaders",url:"https://cardinalblue.github.io/android-kraft-shade/docs/getting-started/first-effect",totalTime:"PT30M",steps:["Set up the project with KraftShade dependencies and sample images","Create the UI with Jetpack Compose and effect controls","Build the effect pipeline with saturation, sepia, vignette, and grain effects","Create a custom noise overlay shader for film grain effect","Test and adjust the effect parameters in real-time"],supply:["Android Studio","KraftShade library","Sample image resources","Jetpack Compose"]}),"\n",(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"first-effect",children:"First Effect"})}),"\n",(0,i.jsx)(t.p,{children:"In this guide, we'll walk through creating a more complex effect using KraftShade. We'll build a vintage photo effect that combines multiple shaders to achieve a stylized look."}),"\n",(0,i.jsx)(t.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,i.jsx)(t.p,{children:"Before starting, make sure you:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Have completed the ",(0,i.jsx)(t.a,{href:"./installation",children:"Installation"})," steps"]}),"\n",(0,i.jsxs)(t.li,{children:["Understand the ",(0,i.jsx)(t.a,{href:"./basic-concepts",children:"Basic Concepts"})," of KraftShade"]}),"\n",(0,i.jsxs)(t.li,{children:["Have gone through the ",(0,i.jsx)(t.a,{href:"./quick-start-guide",children:"Quick Start Guide"})]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"project-setup",children:"Project Setup"}),"\n",(0,i.jsx)(t.p,{children:"First, let's set up our project with the necessary dependencies and resources:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["Add KraftShade dependencies to your project (see ",(0,i.jsx)(t.a,{href:"./installation",children:"Installation"}),")"]}),"\n",(0,i.jsx)(t.li,{children:"Add sample images to your project resources"}),"\n",(0,i.jsx)(t.li,{children:"Set up logging in your Application class"}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"creating-a-vintage-photo-effect",children:"Creating a Vintage Photo Effect"}),"\n",(0,i.jsx)(t.p,{children:"We'll create a vintage photo effect that combines several shaders:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"Saturation adjustment"}),"\n",(0,i.jsx)(t.li,{children:"Sepia tone"}),"\n",(0,i.jsx)(t.li,{children:"Vignette effect"}),"\n",(0,i.jsx)(t.li,{children:"Grain overlay"}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"step-1-set-up-the-ui",children:"Step 1: Set Up the UI"}),"\n",(0,i.jsx)(t.p,{children:"Let's start by setting up a simple UI to display our effect. We'll use Jetpack Compose for this example:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-kotlin",children:'@Composable\nfun VintageEffectDemo() {\n    val state = rememberKraftShadeEffectState()\n    \n    var aspectRatio by remember { mutableFloatStateOf(1f) }\n    var image by remember { mutableStateOf<Bitmap?>(null) }\n    \n    // Parameters for our effect\n    var saturation by remember { mutableFloatStateOf(0.7f) }\n    var sepiaIntensity by remember { mutableFloatStateOf(0.8f) }\n    var vignetteStart by remember { mutableFloatStateOf(0.3f) }\n    var vignetteEnd by remember { mutableFloatStateOf(0.75f) }\n    var grainIntensity by remember { mutableFloatStateOf(0.1f) }\n    \n    val context = LocalContext.current\n    \n    // Load image and set aspect ratio\n    LaunchedEffect(Unit) {\n        val bitmap = BitmapFactory.decodeResource(context.resources, R.drawable.sample_image)\n        image = bitmap\n        aspectRatio = bitmap.width.toFloat() / bitmap.height.toFloat()\n    }\n    \n    // Set up the UI layout\n    Column(\n        modifier = Modifier.fillMaxSize(),\n        horizontalAlignment = Alignment.CenterHorizontally\n    ) {\n        // Image preview with effects\n        Box(\n            modifier = Modifier\n                .fillMaxHeight(0.5f)\n                .fillMaxWidth(),\n            contentAlignment = Alignment.Center,\n        ) {\n            KraftShadeEffectView(\n                modifier = Modifier.aspectRatio(aspectRatio),\n                state = state\n            )\n        }\n        \n        // Effect controls\n        LazyColumn(\n            modifier = Modifier\n                .fillMaxWidth()\n                .padding(16.dp)\n        ) {\n            item {\n                Text("Saturation: ${String.format("%.1f", saturation)}")\n                Slider(\n                    value = saturation,\n                    onValueChange = {\n                        saturation = it\n                        state.requestRender()\n                    },\n                    valueRange = 0f..1f\n                )\n            }\n            \n            item {\n                Text("Sepia Intensity: ${String.format("%.1f", sepiaIntensity)}")\n                Slider(\n                    value = sepiaIntensity,\n                    onValueChange = {\n                        sepiaIntensity = it\n                        state.requestRender()\n                    },\n                    valueRange = 0f..1f\n                )\n            }\n            \n            item {\n                Text("Vignette Start: ${String.format("%.1f", vignetteStart)}")\n                Slider(\n                    value = vignetteStart,\n                    onValueChange = {\n                        vignetteStart = it\n                        state.requestRender()\n                    },\n                    valueRange = 0f..1f\n                )\n            }\n            \n            item {\n                Text("Vignette End: ${String.format("%.1f", vignetteEnd)}")\n                Slider(\n                    value = vignetteEnd,\n                    onValueChange = {\n                        vignetteEnd = it\n                        state.requestRender()\n                    },\n                    valueRange = 0f..1f\n                )\n            }\n            \n            item {\n                Text("Grain Intensity: ${String.format("%.1f", grainIntensity)}")\n                Slider(\n                    value = grainIntensity,\n                    onValueChange = {\n                        grainIntensity = it\n                        state.requestRender()\n                    },\n                    valueRange = 0f..0.5f\n                )\n            }\n        }\n    }\n    \n    // Apply the effect\n    LaunchedEffect(Unit) {\n        state.setEffect { targetBuffer ->\n            createVintageEffect(targetBuffer, image, saturation, sepiaIntensity, vignetteStart, vignetteEnd, grainIntensity)\n        }\n    }\n}\n'})}),"\n",(0,i.jsx)(t.h3,{id:"step-2-create-the-effect-pipeline",children:"Step 2: Create the Effect Pipeline"}),"\n",(0,i.jsxs)(t.p,{children:["Now, let's implement the ",(0,i.jsx)(t.code,{children:"createVintageEffect"})," function that will set up our pipeline:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-kotlin",children:'private fun createVintageEffect(\n    targetBuffer: GlBufferProvider,\n    image: Bitmap?,\n    saturation: Float,\n    sepiaIntensity: Float,\n    vignetteStart: Float,\n    vignetteEnd: Float,\n    grainIntensity: Float\n): Pipeline? {\n    if (image == null) return null\n    \n    return pipeline(targetBuffer) {\n        // Create buffer references for intermediate results\n        val (saturationResult, sepiaResult, vignetteResult) = createBufferReferences(\n            "saturation_result",\n            "sepia_result",\n            "vignette_result"\n        )\n        \n        // Step 1: Apply saturation adjustment\n        step(\n            SaturationKraftShader(),\n            inputTexture = sampledBitmapTextureProvider { image },\n            targetBuffer = saturationResult\n        ) { shader ->\n            shader.saturation = sampledInput { saturation }\n        }\n        \n        // Step 2: Apply sepia tone\n        step(\n            SepiaToneKraftShader(),\n            inputTexture = saturationResult,\n            targetBuffer = sepiaResult\n        ) { shader ->\n            shader.intensity = sampledInput { sepiaIntensity }\n        }\n        \n        // Step 3: Apply vignette effect\n        step(\n            VignetteKraftShader(),\n            inputTexture = sepiaResult,\n            targetBuffer = vignetteResult\n        ) { shader ->\n            shader.vignetteStart = sampledInput { vignetteStart }\n            shader.vignetteEnd = sampledInput { vignetteEnd }\n        }\n        \n        // Step 4: Apply grain effect and render to final target\n        step(\n            NoiseOverlayKraftShader(),\n            inputTexture = vignetteResult,\n            targetBuffer = targetBuffer\n        ) { shader ->\n            shader.intensity = sampledInput { grainIntensity }\n        }\n    }\n}\n'})}),"\n",(0,i.jsx)(t.h3,{id:"step-3-create-a-custom-noise-overlay-shader",children:"Step 3: Create a Custom Noise Overlay Shader"}),"\n",(0,i.jsx)(t.p,{children:"For the grain effect, we'll create a custom shader. This demonstrates how to extend KraftShade with your own shaders:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-kotlin",children:'class NoiseOverlayKraftShader : TextureInputKraftShader() {\n    var intensity by glUniform1f("u_intensity", 0.1f)\n    \n    override val fragmentShaderSource: String = """\n        precision mediump float;\n        varying vec2 v_texCoord;\n        uniform sampler2D s_texture;\n        uniform float u_intensity;\n        \n        // Simple pseudo-random function\n        float random(vec2 st) {\n            return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n        }\n        \n        void main() {\n            vec4 color = texture2D(s_texture, v_texCoord);\n            float noise = random(v_texCoord) * u_intensity;\n            \n            // Add noise to each channel\n            color.rgb += noise;\n            \n            gl_FragColor = color;\n        }\n    """\n}\n'})}),"\n",(0,i.jsx)(t.h2,{id:"understanding-the-pipeline",children:"Understanding the Pipeline"}),"\n",(0,i.jsx)(t.p,{children:"Let's break down what's happening in our vintage effect pipeline:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Buffer References"}),": We create named buffer references for intermediate results. This helps with debugging and makes the pipeline more readable."]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Serial Processing"}),": We process the image through a series of steps:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Saturation adjustment: Reduces the color saturation for a faded look"}),"\n",(0,i.jsx)(t.li,{children:"Sepia tone: Adds a warm, brownish tint characteristic of old photos"}),"\n",(0,i.jsx)(t.li,{children:"Vignette: Darkens the edges of the image"}),"\n",(0,i.jsx)(t.li,{children:"Noise overlay: Adds film grain for an authentic vintage feel"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Dynamic Parameters"}),": Each shader has parameters that can be adjusted in real-time using the sliders in our UI."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"extending-the-effect",children:"Extending the Effect"}),"\n",(0,i.jsx)(t.p,{children:"You can extend this effect in several ways:"}),"\n",(0,i.jsx)(t.h3,{id:"adding-color-grading-with-lookuptablekraftshader",children:"Adding Color Grading with LookUpTableKraftShader"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-kotlin",children:"// Add after the vignette step\nstep(\n    LookUpTableKraftShader(),\n    inputTexture = vignetteResult,\n    targetBuffer = lookupResult\n) { shader ->\n    shader.intensity = sampledInput { lookupIntensity }\n    shader.lookupTexture = sampledBitmapTextureProvider { lookupBitmap }\n}\n"})}),"\n",(0,i.jsx)(t.h3,{id:"adding-a-subtle-blur",children:"Adding a Subtle Blur"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-kotlin",children:"// Add after the saturation step\nstep(\n    CircularBlurKraftShader(),\n    inputTexture = saturationResult,\n    targetBuffer = blurResult\n) { shader ->\n    shader.blurRadius = sampledInput { blurRadius }\n}\n"})}),"\n",(0,i.jsx)(t.h2,{id:"using-the-graph-pipeline-for-complex-effects",children:"Using the Graph Pipeline for Complex Effects"}),"\n",(0,i.jsx)(t.p,{children:"For more complex effects, you can use the graph pipeline to create non-linear processing flows:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-kotlin",children:'pipeline(targetBuffer) {\n    // Create buffer references\n    val (baseProcessed, overlay, blended) = createBufferReferences(\n        "base_processed",\n        "overlay",\n        "blended"\n    )\n    \n    // Process the base image\n    step(\n        SaturationKraftShader(),\n        inputTexture = sampledBitmapTextureProvider { baseImage },\n        targetBuffer = baseProcessed\n    ) { shader ->\n        shader.saturation = sampledInput { saturation }\n    }\n    \n    // Create an overlay effect\n    step(\n        EdgeDetectionKraftShader(),\n        inputTexture = sampledBitmapTextureProvider { baseImage },\n        targetBuffer = overlay\n    ) { shader ->\n        shader.intensity = sampledInput { edgeIntensity }\n    }\n    \n    // Blend the two results\n    step(\n        ScreenBlendKraftShader(),\n        targetBuffer = blended\n    ) { shader ->\n        shader.setTexture1(baseProcessed)\n        shader.setTexture2(overlay)\n    }\n    \n    // Final adjustments\n    step(\n        ContrastKraftShader(),\n        inputTexture = blended,\n        targetBuffer = targetBuffer\n    ) { shader ->\n        shader.contrast = sampledInput { contrast }\n    }\n}\n'})}),"\n",(0,i.jsx)(t.h2,{id:"serializing-your-effect",children:"Serializing Your Effect"}),"\n",(0,i.jsx)(t.p,{children:"Once you've created an effect you like, you can serialize it for later use:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-kotlin",children:'// Serialize the effect\nval serializer = EffectSerializer(context, GlSize(1024, 1024))\nval jsonString = serializer.serialize { targetBuffer ->\n    createVintageEffect(targetBuffer, image, 0.7f, 0.8f, 0.3f, 0.75f, 0.1f)\n}\n\n// Save the JSON string to a file or database\ncontext.openFileOutput("vintage_effect.json", Context.MODE_PRIVATE).use {\n    it.write(jsonString.toByteArray())\n}\n\n// Later, deserialize and apply the effect\nval json = context.openFileInput("vintage_effect.json").bufferedReader().use { it.readText() }\nval serializedEffect = SerializedEffect(json) { textureId ->\n    when (textureId) {\n        "input" -> sampledBitmapTextureProvider("input") { image }\n        else -> null\n    }\n}\n\nstate.setEffect { targetBuffer ->\n    createEffectExecutionProvider(serializedEffect)\n}\n'})}),"\n",(0,i.jsx)(t.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,i.jsx)(t.p,{children:"Now that you've created your first complex effect with KraftShade, you can:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Explore the ",(0,i.jsx)(t.a,{href:"../core-components",children:"Core Components"})," in more detail"]}),"\n",(0,i.jsxs)(t.li,{children:["Learn about the ",(0,i.jsx)(t.a,{href:"../pipeline-dsl",children:"Pipeline DSL"})," for building even more complex effects"]}),"\n",(0,i.jsxs)(t.li,{children:["Check out the ",(0,i.jsx)(t.a,{href:"../built-in-shaders",children:"Built-in Shaders"})," for more ready-to-use effects"]}),"\n",(0,i.jsx)(t.li,{children:"Dive into Advanced Topics like custom shader development and performance optimization"}),"\n"]})]})}function u(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(f,{...e})}):f(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>l});var a=n(6540);const i={},r=a.createContext(i);function s(e){const t=a.useContext(r);return a.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),a.createElement(r.Provider,{value:t},e.children)}}}]);